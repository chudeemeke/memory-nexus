---
phase: 02-database-schema-and-ports
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/infrastructure/database/schema.ts
  - src/infrastructure/database/schema.test.ts
autonomous: true

must_haves:
  truths:
    - "Database schema defines all required tables for session storage"
    - "FTS5 virtual table is created for full-text search"
    - "External content pattern separates FTS index from metadata"
    - "Triggers keep FTS5 index synchronized with content table"
  artifacts:
    - path: "src/infrastructure/database/schema.ts"
      provides: "SQL schema DDL statements and schema creation function"
      exports: ["SCHEMA_SQL", "createSchema", "SESSIONS_TABLE", "MESSAGES_META_TABLE", "MESSAGES_FTS_TABLE", "TOOL_USES_TABLE", "LINKS_TABLE", "TOPICS_TABLE", "EXTRACTION_STATE_TABLE"]
    - path: "src/infrastructure/database/schema.test.ts"
      provides: "Schema creation tests"
      min_lines: 100
  key_links:
    - from: "src/infrastructure/database/schema.ts"
      to: "bun:sqlite"
      via: "Database type import"
      pattern: "import.*Database.*from.*bun:sqlite"
---

<objective>
Define the complete SQLite schema with FTS5 full-text search support.

Purpose: Create the database structure that will store sessions, messages, tool uses, links, topics, and extraction state. The schema uses external content FTS5 tables for efficient full-text search while keeping metadata in regular tables.

Output: Schema SQL as exportable constants with a createSchema function that builds the database structure.
</objective>

<execution_context>
@~/.claude/get-stuff-done/workflows/execute-plan.md
@~/.claude/get-stuff-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-database-schema-and-ports/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define schema SQL constants</name>
  <files>src/infrastructure/database/schema.ts</files>
  <action>
Create schema.ts with SQL DDL statements as string constants:

SESSIONS_TABLE:
```sql
CREATE TABLE IF NOT EXISTS sessions (
    id TEXT PRIMARY KEY,
    project_path_encoded TEXT NOT NULL,
    project_path_decoded TEXT NOT NULL,
    project_name TEXT NOT NULL,
    start_time TEXT NOT NULL,
    end_time TEXT,
    message_count INTEGER DEFAULT 0,
    created_at TEXT DEFAULT (datetime('now')),
    updated_at TEXT DEFAULT (datetime('now'))
);
CREATE INDEX IF NOT EXISTS idx_sessions_project ON sessions(project_path_encoded);
CREATE INDEX IF NOT EXISTS idx_sessions_start_time ON sessions(start_time);
```

MESSAGES_META_TABLE (content table for FTS5):
```sql
CREATE TABLE IF NOT EXISTS messages_meta (
    rowid INTEGER PRIMARY KEY AUTOINCREMENT,
    id TEXT UNIQUE NOT NULL,
    session_id TEXT NOT NULL,
    role TEXT NOT NULL CHECK (role IN ('user', 'assistant')),
    content TEXT NOT NULL,
    timestamp TEXT NOT NULL,
    tool_use_ids TEXT,
    FOREIGN KEY (session_id) REFERENCES sessions(id) ON DELETE CASCADE
);
CREATE INDEX IF NOT EXISTS idx_messages_session ON messages_meta(session_id);
CREATE INDEX IF NOT EXISTS idx_messages_timestamp ON messages_meta(timestamp);
```

MESSAGES_FTS_TABLE (FTS5 external content):
```sql
CREATE VIRTUAL TABLE IF NOT EXISTS messages_fts USING fts5(
    content,
    content=messages_meta,
    content_rowid=rowid,
    tokenize='porter unicode61'
);
```

FTS_TRIGGERS (synchronization triggers):
```sql
CREATE TRIGGER IF NOT EXISTS messages_fts_insert AFTER INSERT ON messages_meta BEGIN
    INSERT INTO messages_fts(rowid, content) VALUES (new.rowid, new.content);
END;

CREATE TRIGGER IF NOT EXISTS messages_fts_delete AFTER DELETE ON messages_meta BEGIN
    INSERT INTO messages_fts(messages_fts, rowid, content) VALUES('delete', old.rowid, old.content);
END;

CREATE TRIGGER IF NOT EXISTS messages_fts_update AFTER UPDATE ON messages_meta BEGIN
    INSERT INTO messages_fts(messages_fts, rowid, content) VALUES('delete', old.rowid, old.content);
    INSERT INTO messages_fts(rowid, content) VALUES (new.rowid, new.content);
END;
```

TOOL_USES_TABLE:
```sql
CREATE TABLE IF NOT EXISTS tool_uses (
    id TEXT PRIMARY KEY,
    session_id TEXT NOT NULL,
    name TEXT NOT NULL,
    input TEXT NOT NULL,
    timestamp TEXT NOT NULL,
    status TEXT NOT NULL CHECK (status IN ('pending', 'success', 'error')),
    result TEXT,
    FOREIGN KEY (session_id) REFERENCES sessions(id) ON DELETE CASCADE
);
CREATE INDEX IF NOT EXISTS idx_tool_uses_session ON tool_uses(session_id);
CREATE INDEX IF NOT EXISTS idx_tool_uses_name ON tool_uses(name);
```

LINKS_TABLE:
```sql
CREATE TABLE IF NOT EXISTS links (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    source_type TEXT NOT NULL CHECK (source_type IN ('session', 'message', 'topic')),
    source_id TEXT NOT NULL,
    target_type TEXT NOT NULL CHECK (target_type IN ('session', 'message', 'topic')),
    target_id TEXT NOT NULL,
    relationship TEXT NOT NULL CHECK (relationship IN ('mentions', 'related_to', 'continues')),
    weight REAL DEFAULT 1.0 CHECK (weight >= 0 AND weight <= 1),
    UNIQUE(source_type, source_id, target_type, target_id, relationship)
);
CREATE INDEX IF NOT EXISTS idx_links_source ON links(source_type, source_id);
CREATE INDEX IF NOT EXISTS idx_links_target ON links(target_type, target_id);
```

TOPICS_TABLE:
```sql
CREATE TABLE IF NOT EXISTS topics (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT UNIQUE NOT NULL,
    created_at TEXT DEFAULT (datetime('now'))
);
CREATE INDEX IF NOT EXISTS idx_topics_name ON topics(name);
```

EXTRACTION_STATE_TABLE:
```sql
CREATE TABLE IF NOT EXISTS extraction_state (
    id TEXT PRIMARY KEY,
    session_path TEXT UNIQUE NOT NULL,
    started_at TEXT NOT NULL,
    status TEXT NOT NULL CHECK (status IN ('pending', 'in_progress', 'complete', 'error')),
    completed_at TEXT,
    messages_extracted INTEGER DEFAULT 0,
    error_message TEXT,
    file_mtime TEXT,
    file_size INTEGER
);
CREATE INDEX IF NOT EXISTS idx_extraction_session_path ON extraction_state(session_path);
CREATE INDEX IF NOT EXISTS idx_extraction_status ON extraction_state(status);
```

Export each as a named constant and combine into SCHEMA_SQL array.
  </action>
  <verify>
- File compiles: bun build --dry-run src/infrastructure/database/schema.ts
- All table constants exported
- SQL syntax appears valid (no obvious errors)
  </verify>
  <done>
Schema SQL constants defined for all 7 tables plus FTS5 virtual table and synchronization triggers.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create schema application function</name>
  <files>src/infrastructure/database/schema.ts</files>
  <action>
Add to schema.ts:

createSchema function:
```typescript
import { Database } from "bun:sqlite";

export function createSchema(db: Database): void {
    // Execute all schema statements in order
    for (const sql of SCHEMA_SQL) {
        db.exec(sql);
    }
}
```

checkFts5Support function:
```typescript
export function checkFts5Support(db: Database): boolean {
    try {
        db.exec("CREATE VIRTUAL TABLE _fts5_check USING fts5(test)");
        db.exec("DROP TABLE _fts5_check");
        return true;
    } catch {
        return false;
    }
}
```

Export SCHEMA_SQL as the ordered array of all DDL statements.

Order matters:
1. sessions (no dependencies)
2. messages_meta (depends on sessions)
3. messages_fts (depends on messages_meta)
4. FTS triggers (depend on both)
5. tool_uses (depends on sessions)
6. links (no foreign keys)
7. topics (no dependencies)
8. extraction_state (no dependencies)
  </action>
  <verify>
- createSchema exported
- checkFts5Support exported
- SCHEMA_SQL is an array
  </verify>
  <done>
Schema application function creates all tables in dependency order. FTS5 support check enables graceful degradation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add schema unit tests</name>
  <files>src/infrastructure/database/schema.test.ts</files>
  <action>
Create schema.test.ts with tests:

1. Schema creation test:
- Create in-memory database: new Database(":memory:")
- Call createSchema(db)
- Query sqlite_master for table names
- Assert all expected tables exist

2. FTS5 virtual table test:
- Create in-memory database
- Create schema
- Verify messages_fts exists as virtual table
- Insert into messages_meta
- Verify FTS5 trigger fires (query messages_fts)

3. FTS5 trigger sync test:
- Insert a message
- Search via messages_fts MATCH
- Verify result found
- Delete the message
- Search again
- Verify no results

4. FTS5 support check test:
- Create in-memory database
- Call checkFts5Support(db)
- Assert returns true (Bun includes FTS5)

5. Schema idempotency test:
- Create schema twice
- Should not throw (IF NOT EXISTS)

6. Foreign key constraint test:
- Create schema
- Try to insert message with invalid session_id
- Should fail (if foreign keys enabled)

7. Check constraint test:
- Try to insert message with invalid role
- Should fail

Test setup pattern:
```typescript
import { describe, it, expect, beforeEach, afterEach } from "bun:test";
import { Database } from "bun:sqlite";
import { createSchema, checkFts5Support, SCHEMA_SQL } from "./schema.js";

describe("Database Schema", () => {
    let db: Database;

    beforeEach(() => {
        db = new Database(":memory:");
        db.exec("PRAGMA foreign_keys = ON;");
    });

    afterEach(() => {
        db.close();
    });

    // tests...
});
```
  </action>
  <verify>
- bun test src/infrastructure/database/schema.test.ts passes
- All 7 test cases pass
- FTS5 MATCH query works in tests
  </verify>
  <done>
Schema tests verify table creation, FTS5 functionality, trigger synchronization, and constraint enforcement.
  </done>
</task>

</tasks>

<verification>
Schema satisfies SETUP-03 requirements:
- [ ] sessions table created with project path columns
- [ ] messages_meta table created with foreign key to sessions
- [ ] messages_fts FTS5 virtual table created with external content
- [ ] Synchronization triggers keep FTS5 index updated
- [ ] tool_uses table created with session reference
- [ ] links table created for graph traversal
- [ ] topics table created for topic storage
- [ ] extraction_state table created for incremental sync
- [ ] All tests pass: bun test src/infrastructure/database/schema.test.ts
</verification>

<success_criteria>
1. SCHEMA_SQL contains all DDL statements in correct order
2. createSchema function applies schema without errors
3. checkFts5Support detects FTS5 availability
4. FTS5 MATCH queries work after trigger-based indexing
5. All unit tests pass (7 test cases minimum)
6. Schema is idempotent (can run twice safely)
</success_criteria>

<output>
After completion, create `.planning/phases/02-database-schema-and-ports/02-02-SUMMARY.md`
</output>
