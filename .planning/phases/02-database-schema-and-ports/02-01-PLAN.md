---
phase: 02-database-schema-and-ports
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/domain/ports/index.ts
  - src/domain/ports/repositories.ts
  - src/domain/ports/services.ts
  - src/domain/ports/sources.ts
  - src/domain/ports/types.ts
autonomous: true

must_haves:
  truths:
    - "Port interfaces define contracts without implementation details"
    - "All repository methods return Promise types for async compatibility"
    - "Interfaces use domain entities and value objects exclusively"
    - "No SQL or infrastructure types leak into port definitions"
  artifacts:
    - path: "src/domain/ports/repositories.ts"
      provides: "ISessionRepository, IMessageRepository interfaces"
      exports: ["ISessionRepository", "IMessageRepository"]
    - path: "src/domain/ports/services.ts"
      provides: "ISearchService interface with SearchOptions"
      exports: ["ISearchService", "SearchOptions"]
    - path: "src/domain/ports/sources.ts"
      provides: "ISessionSource, IEventParser interfaces"
      exports: ["ISessionSource", "IEventParser", "SessionFileInfo", "ParsedEvent"]
    - path: "src/domain/ports/types.ts"
      provides: "Shared types for parsed events"
      exports: ["ParsedEvent", "UserEventData", "AssistantEventData", "ToolUseEventData", "ToolResultEventData", "SummaryEventData", "SystemEventData"]
  key_links:
    - from: "src/domain/ports/repositories.ts"
      to: "src/domain/entities/session.ts"
      via: "import type { Session }"
      pattern: "import.*Session.*from.*entities"
    - from: "src/domain/ports/repositories.ts"
      to: "src/domain/entities/message.ts"
      via: "import type { Message }"
      pattern: "import.*Message.*from.*entities"
    - from: "src/domain/ports/services.ts"
      to: "src/domain/value-objects/search-query.ts"
      via: "import type { SearchQuery }"
      pattern: "import.*SearchQuery.*from.*value-objects"
---

<objective>
Define all port interfaces for the memory-nexus application following hexagonal architecture.

Purpose: Establish the contract between domain and infrastructure layers. These interfaces will be implemented by SQLite repositories, filesystem sources, and JSONL parsers in later phases.

Output: Complete port interface definitions in src/domain/ports/ with full TypeScript signatures, JSDoc documentation, and proper exports.
</objective>

<execution_context>
@~/.claude/get-stuff-done/workflows/execute-plan.md
@~/.claude/get-stuff-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-database-schema-and-ports/02-RESEARCH.md

Reference existing domain entities:
@src/domain/entities/session.ts
@src/domain/entities/message.ts
@src/domain/entities/tool-use.ts
@src/domain/entities/link.ts
@src/domain/entities/extraction-state.ts
@src/domain/value-objects/project-path.ts
@src/domain/value-objects/search-query.ts
@src/domain/value-objects/search-result.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define repository port interfaces</name>
  <files>src/domain/ports/repositories.ts</files>
  <action>
Create repository interfaces for session and message persistence:

ISessionRepository:
- findById(id: string): Promise<Session | null>
- findByProject(projectPath: ProjectPath): Promise<Session[]>
- findRecent(limit: number): Promise<Session[]>
- save(session: Session): Promise<void>
- saveMany(sessions: Session[]): Promise<void>
- delete(id: string): Promise<void>

IMessageRepository:
- findById(id: string): Promise<Message | null>
- findBySession(sessionId: string): Promise<Message[]>
- save(message: Message, sessionId: string): Promise<void>
- saveMany(messages: Array<{ message: Message; sessionId: string }>): Promise<void>

IToolUseRepository:
- findById(id: string): Promise<ToolUse | null>
- findBySession(sessionId: string): Promise<ToolUse[]>
- save(toolUse: ToolUse, sessionId: string): Promise<void>
- saveMany(toolUses: Array<{ toolUse: ToolUse; sessionId: string }>): Promise<void>

ILinkRepository:
- findBySource(sourceType: EntityType, sourceId: string): Promise<Link[]>
- findByTarget(targetType: EntityType, targetId: string): Promise<Link[]>
- findRelated(entityType: EntityType, entityId: string, maxHops?: number): Promise<Link[]>
- save(link: Link): Promise<void>
- saveMany(links: Link[]): Promise<void>

IExtractionStateRepository:
- findById(id: string): Promise<ExtractionState | null>
- findBySessionPath(sessionPath: string): Promise<ExtractionState | null>
- findPending(): Promise<ExtractionState[]>
- save(state: ExtractionState): Promise<void>

Import domain entities with "import type" syntax to maintain domain purity.
Add JSDoc comments explaining each interface's purpose.
  </action>
  <verify>
- File compiles without errors: bun build --dry-run src/domain/ports/repositories.ts
- No runtime imports (only "import type")
- All methods return Promise types
  </verify>
  <done>
Repository interfaces defined with complete signatures. All methods documented with JSDoc. Imports use "import type" for domain purity.
  </done>
</task>

<task type="auto">
  <name>Task 2: Define service and source port interfaces</name>
  <files>src/domain/ports/services.ts, src/domain/ports/sources.ts, src/domain/ports/types.ts</files>
  <action>
Create service interfaces in services.ts:

ISearchService:
- search(query: SearchQuery, options?: SearchOptions): Promise<SearchResult[]>

SearchOptions interface:
- limit?: number
- projectFilter?: ProjectPath
- roleFilter?: "user" | "assistant"
- sinceDate?: Date
- beforeDate?: Date

Create source interfaces in sources.ts:

ISessionSource:
- discoverSessions(): Promise<SessionFileInfo[]>
- getSessionFile(sessionId: string): Promise<string | null>

SessionFileInfo interface:
- id: string
- path: string
- projectPath: ProjectPath
- modifiedTime: Date
- size: number

IEventParser:
- parse(filePath: string): AsyncIterable<ParsedEvent>

Create event types in types.ts:

ParsedEvent discriminated union:
- { type: "user"; data: UserEventData }
- { type: "assistant"; data: AssistantEventData }
- { type: "tool_use"; data: ToolUseEventData }
- { type: "tool_result"; data: ToolResultEventData }
- { type: "summary"; data: SummaryEventData }
- { type: "system"; data: SystemEventData }
- { type: "skipped"; reason: string }

Event data interfaces based on JSONL-EVENT-SCHEMA.md research:
- UserEventData: { uuid: string; message: { content: string }; timestamp: string }
- AssistantEventData: { uuid: string; message: { content: Array<ContentBlock> }; timestamp: string }
- ToolUseEventData: { uuid: string; name: string; input: Record<string, unknown>; timestamp: string }
- ToolResultEventData: { uuid: string; toolUseId: string; content: string; isError: boolean; timestamp: string }
- SummaryEventData: { content: string; timestamp: string }
- SystemEventData: { subtype: string; data: unknown; timestamp: string }

ContentBlock type for assistant messages:
- { type: "text"; text: string } | { type: "tool_use"; id: string; name: string; input: Record<string, unknown> }
  </action>
  <verify>
- Files compile without errors: bun build --dry-run src/domain/ports/services.ts src/domain/ports/sources.ts src/domain/ports/types.ts
- No circular dependencies
- All types are exportable
  </verify>
  <done>
Service and source interfaces defined. ParsedEvent discriminated union enables type-safe event handling. All event data types documented.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update ports index and add unit tests</name>
  <files>src/domain/ports/index.ts, src/domain/ports/ports.test.ts</files>
  <action>
Update index.ts to export all port interfaces:
- Export all from repositories.ts
- Export all from services.ts
- Export all from sources.ts
- Export all from types.ts

Create ports.test.ts to verify:
1. All interfaces are exported (compile-time check via import)
2. Type compatibility tests - create mock implementations to verify interface contracts work
3. ParsedEvent discriminated union works with type narrowing
4. SearchOptions has all optional properties
5. SessionFileInfo has required projectPath property

Use describe/it blocks. Test pattern:
- Import interfaces
- Create conforming objects
- Verify type assignments work
- For discriminated unions, test type narrowing with switch/case

These are structural tests verifying the interfaces are usable, not behavioral tests.
  </action>
  <verify>
- bun test src/domain/ports/ports.test.ts passes
- All exports accessible from @src/domain/ports
- No TypeScript errors in test file
  </verify>
  <done>
Ports index exports all interfaces. Test file verifies interface contracts are usable with mock implementations.
  </done>
</task>

</tasks>

<verification>
All port interfaces satisfy Phase 2 requirement DOM-09:
- [ ] ISessionRepository defined with all CRUD operations
- [ ] IMessageRepository defined with session-scoped queries
- [ ] ISearchService defined with SearchOptions
- [ ] ISessionSource defined for file discovery
- [ ] IEventParser defined with AsyncIterable pattern
- [ ] All interfaces use Promise return types
- [ ] All interfaces reference domain types only (no SQL, no infrastructure)
- [ ] bun test passes for port tests
</verification>

<success_criteria>
1. All 5 port interfaces defined (ISessionRepository, IMessageRepository, ISearchService, ISessionSource, IEventParser)
2. Supporting interfaces defined (IToolUseRepository, ILinkRepository, IExtractionStateRepository, SearchOptions, SessionFileInfo, ParsedEvent)
3. Domain purity maintained (import type only)
4. Tests verify interface usability
5. TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-database-schema-and-ports/02-01-SUMMARY.md`
</output>
