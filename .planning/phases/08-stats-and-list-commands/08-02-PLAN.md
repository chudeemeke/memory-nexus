---
phase: 08-stats-and-list-commands
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/domain/ports/repositories.ts
  - src/infrastructure/database/repositories/session-repository.ts
  - src/infrastructure/database/repositories/session-repository.test.ts
  - src/presentation/cli/commands/list.ts
  - src/presentation/cli/commands/list.test.ts
  - src/presentation/cli/commands/index.ts
  - src/presentation/cli/formatters/list-formatter.ts
  - src/presentation/cli/formatters/list-formatter.test.ts
  - src/presentation/cli/formatters/index.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can run `memory list` and see recent sessions"
    - "User can filter sessions by project with --project"
    - "User can filter sessions by date with --days, --since, --before"
    - "Empty results show 'no sessions found' message"
  artifacts:
    - path: "src/domain/ports/repositories.ts"
      provides: "SessionListOptions interface"
      contains: "interface SessionListOptions"
    - path: "src/infrastructure/database/repositories/session-repository.ts"
      provides: "findFiltered method"
      contains: "async findFiltered"
    - path: "src/presentation/cli/commands/list.ts"
      provides: "List CLI command"
      exports: ["createListCommand"]
    - path: "src/presentation/cli/formatters/list-formatter.ts"
      provides: "Session list formatting"
      exports: ["createListFormatter"]
  key_links:
    - from: "src/presentation/cli/commands/list.ts"
      to: "SqliteSessionRepository"
      via: "findFiltered call"
      pattern: "sessionRepo\\.findFiltered"
    - from: "src/presentation/cli/commands/list.ts"
      to: "list-formatter"
      via: "formatter factory"
      pattern: "createListFormatter"
    - from: "src/presentation/cli/commands/list.ts"
      to: "date-parser"
      via: "parseDate import"
      pattern: "parseDate"
---

<objective>
Implement session list command with project and date filtering.

Purpose: Enable users to discover sessions in their memory database - see recent sessions, filter by project, filter by time range.

Output: Working `memory list` command with filtering and formatted output.
</objective>

<execution_context>
@C:\Users\Destiny\.claude/get-stuff-done/workflows/execute-plan.md
@C:\Users\Destiny\.claude/get-stuff-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-stats-and-list-commands/08-RESEARCH.md

# Existing patterns to follow
@src/domain/ports/repositories.ts (ISessionRepository pattern)
@src/infrastructure/database/repositories/session-repository.ts (extend with findFiltered)
@src/presentation/cli/commands/search.ts (list command pattern - filtering, date parsing)
@src/presentation/cli/formatters/output-formatter.ts (list-formatter pattern)
@src/presentation/cli/parsers/date-parser.ts (parseDate for --since/--before)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend session repository with findFiltered method</name>
  <files>
    src/domain/ports/repositories.ts
    src/infrastructure/database/repositories/session-repository.ts
    src/infrastructure/database/repositories/session-repository.test.ts
  </files>
  <action>
1. In `src/domain/ports/repositories.ts`, add after ISessionRepository definition:

```typescript
/**
 * Options for filtering session list.
 */
export interface SessionListOptions {
  /** Maximum sessions to return */
  limit?: number;
  /** Filter by project name (substring match) */
  projectFilter?: string;
  /** Only sessions after this date */
  sinceDate?: Date;
  /** Only sessions before this date */
  beforeDate?: Date;
}
```

2. Add to ISessionRepository interface:
```typescript
/**
 * Find sessions with filtering options.
 * Builds dynamic WHERE clause based on provided filters.
 */
findFiltered(options: SessionListOptions): Promise<Session[]>;
```

3. In `src/infrastructure/database/repositories/session-repository.ts`:
   - Add findFiltered method that builds dynamic WHERE clause
   - Use named parameters ($param style) for safety
   - Project filter uses LIKE with % wildcards on project_name
   - Date filters use >= and <= on start_time
   - Build conditions array and join with AND
   - Always ORDER BY start_time DESC
   - LIMIT defaults to 20 if not specified

Pattern (from research):
```typescript
async findFiltered(options: SessionListOptions): Promise<Session[]> {
  const conditions: string[] = [];
  const params: Record<string, unknown> = {};

  if (options.projectFilter) {
    conditions.push("project_name LIKE $projectFilter");
    params.$projectFilter = `%${options.projectFilter}%`;
  }
  if (options.sinceDate) {
    conditions.push("start_time >= $sinceDate");
    params.$sinceDate = options.sinceDate.toISOString();
  }
  if (options.beforeDate) {
    conditions.push("start_time <= $beforeDate");
    params.$beforeDate = options.beforeDate.toISOString();
  }

  const whereClause = conditions.length > 0
    ? `WHERE ${conditions.join(" AND ")}`
    : "";
  const limit = options.limit ?? 20;
  params.$limit = limit;

  const sql = `
    SELECT id, project_path_encoded, project_path_decoded, project_name,
           start_time, end_time, message_count
    FROM sessions
    ${whereClause}
    ORDER BY start_time DESC
    LIMIT $limit
  `;

  const stmt = this.db.prepare(sql);
  const rows = stmt.all(params) as SessionRow[];
  return rows.map((row) => this.rowToSession(row));
}
```

4. Add tests in session-repository.test.ts:
   - Test findFiltered with no options returns recent sessions
   - Test findFiltered with limit
   - Test findFiltered with projectFilter (substring match)
   - Test findFiltered with sinceDate
   - Test findFiltered with beforeDate
   - Test findFiltered with combined filters
   - Test empty result when no matches
  </action>
  <verify>
    Run `bun test src/infrastructure/database/repositories/session-repository.test.ts` - all tests pass (expect ~7 new tests)
  </verify>
  <done>
    Session repository supports filtered queries with project and date filtering.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create list output formatter</name>
  <files>
    src/presentation/cli/formatters/list-formatter.ts
    src/presentation/cli/formatters/list-formatter.test.ts
    src/presentation/cli/formatters/index.ts
  </files>
  <action>
1. Create `src/presentation/cli/formatters/list-formatter.ts`:

```typescript
/**
 * List Formatter
 *
 * Strategy pattern for formatting session list results.
 */

import type { Session } from "../../../domain/entities/session.js";
import { formatTimestamp } from "./timestamp-formatter.js";
import { bold, dim } from "./color.js";

export type ListOutputMode = "default" | "json" | "quiet" | "verbose";

export interface ListFormatOptions {
  executionTimeMs?: number;
  filtersApplied?: string[];
}

export interface ListFormatter {
  formatSessions(sessions: Session[], options?: ListFormatOptions): string;
  formatError(error: Error): string;
  formatEmpty(): string;
}

export function createListFormatter(mode: ListOutputMode, useColor: boolean): ListFormatter {
  switch (mode) {
    case "json":
      return new JsonListFormatter();
    case "quiet":
      return new QuietListFormatter();
    case "verbose":
      return new VerboseListFormatter(useColor);
    default:
      return new DefaultListFormatter(useColor);
  }
}
```

2. Implement formatters:
   - DefaultListFormatter: Show sessions as table-like list
     - Session ID (first 8 chars)
     - Project name
     - Relative timestamp (use formatTimestamp from existing)
     - Message count
   - JsonListFormatter: Full session data as JSON array
   - QuietListFormatter: Just session IDs, one per line
   - VerboseListFormatter: Full IDs, all details, timing, filters

3. Format pattern for default:
```
Sessions (20 results):

  abc12345  wow-system        2 hours ago    142 messages
  def67890  memory-nexus      Yesterday      85 messages
  ...
```

4. Empty state: "No sessions found. Run 'memory sync' to import sessions."

5. Create tests:
   - Test default format shows columns
   - Test JSON is valid JSON with all session fields
   - Test quiet outputs only session IDs
   - Test verbose includes timing and filters
   - Test empty state message
   - Test message count pluralization

6. Update `src/presentation/cli/formatters/index.ts`:
   - Export createListFormatter, ListFormatter, ListOutputMode
  </action>
  <verify>
    Run `bun test src/presentation/cli/formatters/list-formatter.test.ts` - all tests pass (expect ~10-12 tests)
  </verify>
  <done>
    List formatter supports all output modes with proper session display.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create list CLI command</name>
  <files>
    src/presentation/cli/commands/list.ts
    src/presentation/cli/commands/list.test.ts
    src/presentation/cli/commands/index.ts
  </files>
  <action>
1. Create `src/presentation/cli/commands/list.ts`:

```typescript
/**
 * List Command Handler
 *
 * CLI command for listing sessions with filtering.
 */

import { Command, Option } from "commander";
import { SqliteSessionRepository } from "../../../infrastructure/database/repositories/session-repository.js";
import type { SessionListOptions } from "../../../domain/ports/repositories.js";
import {
  initializeDatabase,
  closeDatabase,
  getDefaultDbPath,
} from "../../../infrastructure/database/index.js";
import { createListFormatter, type ListOutputMode, type ListFormatOptions } from "../formatters/list-formatter.js";
import { shouldUseColor } from "../formatters/color.js";
import { parseDate, DateParseError } from "../parsers/date-parser.js";

interface ListCommandOptions {
  limit?: string;
  project?: string;
  since?: string;
  before?: string;
  days?: number;
  json?: boolean;
  verbose?: boolean;
  quiet?: boolean;
}

export function createListCommand(): Command {
  return new Command("list")
    .description("List sessions")
    .option("-l, --limit <count>", "Maximum sessions to return", "20")
    .option("-p, --project <name>", "Filter by project name")
    .addOption(
      new Option("--since <date>", "Sessions after date (e.g., 'yesterday', '2 weeks ago')")
        .conflicts("days")
    )
    .addOption(
      new Option("--before <date>", "Sessions before date")
        .conflicts("days")
    )
    .addOption(
      new Option("--days <n>", "Sessions from last N days (includes today)")
        .argParser((val) => {
          const n = parseInt(val, 10);
          if (isNaN(n) || n < 1) throw new Error("Days must be a positive number");
          return n;
        })
        .conflicts(["since", "before"])
    )
    .option("--json", "Output as JSON")
    .addOption(
      new Option("-v, --verbose", "Show detailed output")
        .conflicts("quiet")
    )
    .addOption(
      new Option("-q, --quiet", "Minimal output (session IDs only)")
        .conflicts("verbose")
    )
    .action(async (options: ListCommandOptions) => {
      await executeListCommand(options);
    });
}

export async function executeListCommand(options: ListCommandOptions): Promise<void> {
  const startTime = performance.now();

  // Parse limit
  const limit = parseInt(options.limit ?? "20", 10);
  if (isNaN(limit) || limit < 1) {
    console.error("Error: Limit must be a positive number");
    process.exitCode = 1;
    return;
  }

  // Parse date filters
  let sinceDate: Date | undefined;
  let beforeDate: Date | undefined;

  if (options.days) {
    const now = new Date();
    const startOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    sinceDate = new Date(startOfToday.getTime() - (options.days - 1) * 24 * 60 * 60 * 1000);
  } else {
    if (options.since) {
      try {
        sinceDate = parseDate(options.since);
      } catch (err) {
        if (err instanceof DateParseError) {
          console.error(`Error: ${err.message}`);
          process.exitCode = 1;
          return;
        }
        throw err;
      }
    }
    if (options.before) {
      try {
        beforeDate = parseDate(options.before);
      } catch (err) {
        if (err instanceof DateParseError) {
          console.error(`Error: ${err.message}`);
          process.exitCode = 1;
          return;
        }
        throw err;
      }
    }
  }

  const dbPath = getDefaultDbPath();
  const { db } = initializeDatabase({ path: dbPath });

  try {
    const sessionRepo = new SqliteSessionRepository(db);

    // Build filter options
    const listOptions: SessionListOptions = {
      limit,
      projectFilter: options.project,
      sinceDate,
      beforeDate,
    };

    // Get sessions
    const sessions = await sessionRepo.findFiltered(listOptions);

    // Determine output mode
    let outputMode: ListOutputMode = "default";
    if (options.json) outputMode = "json";
    else if (options.verbose) outputMode = "verbose";
    else if (options.quiet) outputMode = "quiet";

    const useColor = shouldUseColor();
    const formatter = createListFormatter(outputMode, useColor);

    // Check for empty result
    if (sessions.length === 0) {
      console.log(formatter.formatEmpty());
      return;
    }

    // Format and output
    const endTime = performance.now();
    const formatOptions: ListFormatOptions = {
      executionTimeMs: Math.round(endTime - startTime),
      filtersApplied: buildFiltersList(options),
    };
    const output = formatter.formatSessions(sessions, formatOptions);
    console.log(output);

  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    console.error(`Error: ${message}`);
    process.exitCode = 2;
  } finally {
    closeDatabase(db);
  }
}

function buildFiltersList(options: ListCommandOptions): string[] {
  const filters: string[] = [];
  if (options.limit) filters.push(`limit: ${options.limit}`);
  if (options.project) filters.push(`project: ${options.project}`);
  if (options.days) filters.push(`days: ${options.days}`);
  if (options.since) filters.push(`since: ${options.since}`);
  if (options.before) filters.push(`before: ${options.before}`);
  return filters;
}
```

2. Create `src/presentation/cli/commands/list.test.ts`:
   - Test command creation
   - Test help text includes options
   - Test --limit option parsing
   - Test --project option
   - Test --days option with validation
   - Test --days conflicts with --since/--before
   - Test --verbose and --quiet conflict
   - Test --json flag

3. Update `src/presentation/cli/commands/index.ts`:
   - Export createListCommand
  </action>
  <verify>
    Run `bun test src/presentation/cli/commands/list.test.ts` - all tests pass (expect ~10-12 tests)
  </verify>
  <done>
    List command works with project and date filtering, all output modes.
  </done>
</task>

</tasks>

<verification>
1. Run all new tests: `bun test list` - expect ~30 tests to pass
2. Run session repository tests: `bun test session-repository` - all tests pass
3. Run full test suite: `bun test` - all existing tests still pass
4. Manual smoke test (if database has data):
   - `bun run src/index.ts list` - shows recent sessions
   - `bun run src/index.ts list --project memory` - filters by project
   - `bun run src/index.ts list --days 7` - shows last 7 days
   - `bun run src/index.ts list --json` - outputs valid JSON
</verification>

<success_criteria>
1. `memory list` shows recent sessions with ID, project, timestamp, message count
2. `--project` filter matches sessions by project name
3. `--days`, `--since`, `--before` filter by date range
4. All output modes work (default, json, verbose, quiet)
5. Empty result shows helpful message
6. ~30 new tests added and passing
</success_criteria>

<output>
After completion, create `.planning/phases/08-stats-and-list-commands/08-02-SUMMARY.md`
</output>
