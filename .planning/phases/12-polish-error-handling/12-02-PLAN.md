---
phase: 12-polish-error-handling
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/infrastructure/signals/signal-handler.ts
  - src/infrastructure/signals/signal-handler.test.ts
  - src/infrastructure/signals/checkpoint-manager.ts
  - src/infrastructure/signals/checkpoint-manager.test.ts
  - src/infrastructure/signals/index.ts
  - src/infrastructure/index.ts
autonomous: true

must_haves:
  truths:
    - "Ctrl+C prompts user with 3 options"
    - "Second Ctrl+C forces immediate exit"
    - "Sync progress is checkpointed for recovery"
    - "Database connections closed before exit"
  artifacts:
    - path: "src/infrastructure/signals/signal-handler.ts"
      provides: "SIGINT/SIGTERM handling with user prompts"
      exports: ["setupSignalHandlers", "shouldAbort", "registerCleanup"]
    - path: "src/infrastructure/signals/checkpoint-manager.ts"
      provides: "Sync progress checkpointing"
      exports: ["saveCheckpoint", "loadCheckpoint", "clearCheckpoint", "SyncCheckpoint"]
  key_links:
    - from: "src/infrastructure/signals/signal-handler.ts"
      to: "process.on"
      via: "SIGINT/SIGTERM listeners"
      pattern: "process\\.on\\(['\"]SIG"
    - from: "src/infrastructure/signals/checkpoint-manager.ts"
      to: "config directory"
      via: "checkpoint file storage"
      pattern: "\\.memory-nexus"
---

<objective>
Implement signal handling for graceful shutdown and sync checkpoint management.

Purpose: Allow users to interrupt long-running operations (sync, export, purge) cleanly without data corruption. Checkpointing enables recovery on next run ("Resuming from previous interrupted sync").

Output: Signal handler with 3-option Ctrl+C prompt, checkpoint manager for sync progress, and integration with database cleanup.
</objective>

<execution_context>
@C:\Users\Destiny\.claude/get-stuff-done/workflows/execute-plan.md
@C:\Users\Destiny\.claude/get-stuff-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-polish-error-handling/12-CONTEXT.md
@.planning/phases/12-polish-error-handling/12-RESEARCH.md
@src/infrastructure/database/connection.ts
@src/infrastructure/hooks/config-manager.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create checkpoint manager for sync progress</name>
  <files>
    src/infrastructure/signals/checkpoint-manager.ts
    src/infrastructure/signals/checkpoint-manager.test.ts
  </files>
  <action>
    Create checkpoint manager for tracking sync progress:

    1. Create src/infrastructure/signals/checkpoint-manager.ts:
       - Interface SyncCheckpoint:
         - startedAt: string (ISO timestamp)
         - totalSessions: number
         - completedSessions: number
         - completedSessionIds: string[]
         - lastCompletedAt: string | null

       - getCheckpointPath(): string
         - Returns ~/.memory-nexus/sync-checkpoint.json
         - Respect testCheckpointPath override (setTestCheckpointPath pattern)

       - saveCheckpoint(checkpoint: SyncCheckpoint): void
         - Write checkpoint to disk as JSON
         - Create directory if needed
         - Handle errors gracefully (log but don't throw)

       - loadCheckpoint(): SyncCheckpoint | null
         - Read checkpoint from disk
         - Return null if doesn't exist or invalid JSON
         - Log warning on invalid format

       - clearCheckpoint(): void
         - Delete checkpoint file if exists
         - Called on successful sync completion

       - hasCheckpoint(): boolean
         - Quick existence check without loading

       - setTestCheckpointPath(path: string | null): void
         - For test isolation

    2. Create tests in checkpoint-manager.test.ts:
       - Test saveCheckpoint creates file with correct JSON
       - Test loadCheckpoint returns correct data
       - Test loadCheckpoint returns null for missing file
       - Test loadCheckpoint returns null for invalid JSON (with warning)
       - Test clearCheckpoint removes file
       - Test hasCheckpoint returns correct boolean
       - Use test path override for isolation
  </action>
  <verify>
    Run: bun test src/infrastructure/signals/checkpoint-manager.test.ts
    All tests pass.
    Verify checkpoint file format matches interface.
  </verify>
  <done>
    Checkpoint manager can save, load, and clear sync progress.
    Invalid checkpoints handled gracefully.
    Test isolation via path override works.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create signal handler with user prompts</name>
  <files>
    src/infrastructure/signals/signal-handler.ts
    src/infrastructure/signals/signal-handler.test.ts
    src/infrastructure/signals/index.ts
    src/infrastructure/index.ts
  </files>
  <action>
    Create signal handler for graceful shutdown:

    1. Create src/infrastructure/signals/signal-handler.ts:
       - Interface SignalState (module-level):
         - isShuttingDown: boolean
         - interruptCount: number
         - cleanupFunctions: Array<() => Promise<void>>

       - setupSignalHandlers(): void
         - Register handlers for SIGINT and SIGTERM
         - First interrupt: prompt user with 3 options (only if stdin.isTTY)
         - Second interrupt: force exit with code 130
         - If not TTY: default to graceful shutdown (option 2 behavior)

       - promptUser(): Promise<1 | 2 | 3>
         - Use readline.createInterface for prompt
         - Display: "Interrupt received. Choose action:"
           "  1) Abort immediately"
           "  2) Abort after current session (saves progress)"
           "  3) Cancel abort (continue)"
         - Return user choice
         - On invalid input, re-prompt

       - handleChoice(choice: 1 | 2 | 3): Promise<void>
         - Choice 1: Run all cleanups, exit 130
         - Choice 2: Set isShuttingDown = true (loop checks this)
         - Choice 3: Reset state, continue

       - shouldAbort(): boolean
         - Return isShuttingDown state
         - Called by sync loop to check if should stop

       - registerCleanup(fn: () => Promise<void>): void
         - Add cleanup function to list
         - Called by commands to register DB close, etc.

       - unregisterCleanup(fn: () => Promise<void>): void
         - Remove cleanup function
         - Called on successful command completion

       - resetState(): void
         - Reset all state (for testing)

    2. Create tests in signal-handler.test.ts:
       - Test shouldAbort returns false initially
       - Test registerCleanup adds function
       - Test unregisterCleanup removes function
       - Test resetState clears all state
       - Test second interrupt sets force exit (mock process.exit)
       - Note: Interactive prompt testing is complex; focus on state management

    3. Create src/infrastructure/signals/index.ts:
       - Export all from checkpoint-manager.ts and signal-handler.ts

    4. Update src/infrastructure/index.ts:
       - Add export * from "./signals/index.js"
  </action>
  <verify>
    Run: bun test src/infrastructure/signals
    All tests pass.
    Verify signal handler state management works correctly.
  </verify>
  <done>
    Signal handlers registered for SIGINT and SIGTERM.
    shouldAbort() returns correct state.
    Cleanup functions registered and called.
    Second Ctrl+C forces immediate exit.
  </done>
</task>

</tasks>

<verification>
1. Run: bun test src/infrastructure/signals - All signal infrastructure tests pass
2. Verify checkpoint file created at correct path with correct format
3. Verify signal handler respects TTY state for prompts
4. Verify cleanup functions called in order
</verification>

<success_criteria>
1. Checkpoint manager can persist and restore sync progress
2. Signal handler responds to SIGINT/SIGTERM
3. shouldAbort() tracks shutdown state correctly
4. Cleanup functions called before exit
5. Second Ctrl+C forces immediate exit (130)
</success_criteria>

<output>
After completion, create `.planning/phases/12-polish-error-handling/12-02-SUMMARY.md`
</output>
