---
phase: 12-polish-error-handling
plan: 08
type: execute
wave: 3
depends_on: ["12-03"]
files_modified:
  - src/infrastructure/database/connection.ts
  - src/infrastructure/database/connection.test.ts
  - src/presentation/cli/index.ts
autonomous: true

must_haves:
  truths:
    - "Database uses busy_timeout for lock handling"
    - "Quick integrity check runs on startup"
    - "DB corruption offers recreate option"
    - "Connection errors use MemoryNexusError"
  artifacts:
    - path: "src/infrastructure/database/connection.ts"
      provides: "Enhanced connection with busy_timeout and integrity checks"
      contains: "busy_timeout"
  key_links:
    - from: "src/infrastructure/database/connection.ts"
      to: "PRAGMA busy_timeout"
      via: "SQLite busy handling"
      pattern: "busy_timeout"
---

<objective>
Enhance database connection handling with busy timeout, integrity checks, and error recovery.

Purpose: Make database operations robust against concurrent access (WAL mode with busy_timeout) and corruption (quick integrity check on startup with recovery options).

Output: Enhanced database initialization with production-ready error handling.
</objective>

<execution_context>
@C:\Users\Destiny\.claude/get-stuff-done/workflows/execute-plan.md
@C:\Users\Destiny\.claude/get-stuff-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-polish-error-handling/12-CONTEXT.md
@.planning/phases/12-polish-error-handling/12-RESEARCH.md
@src/infrastructure/database/connection.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add busy_timeout and integrity checks to connection</name>
  <files>
    src/infrastructure/database/connection.ts
    src/infrastructure/database/connection.test.ts
  </files>
  <action>
    Enhance database initialization:

    1. Update initializeDatabase in connection.ts:
       - Add PRAGMA busy_timeout = 5000; after WAL mode
       - Add optional quickCheck parameter to DatabaseConfig (default: true)
       - If quickCheck enabled: run checkQuickIntegrity (from health-checker)
       - If integrity fails: throw MemoryNexusError(ErrorCode.DB_CORRUPTED)

    2. Add DatabaseConfig options:
       - busyTimeout?: number (default: 5000ms)
       - quickCheck?: boolean (default: true for file DB, false for :memory:)

    3. Create initializeDatabaseSafe function:
       - Wraps initializeDatabase
       - Catches errors and wraps in MemoryNexusError
       - Returns DatabaseInitResult or throws MemoryNexusError

    4. Add error context to initialization errors:
       - FTS5 not available: error context includes SQLite version
       - Directory creation failed: error context includes path
       - Connection failed: error context includes path and errno

    5. Add tests:
       - Test busy_timeout is set (verify via PRAGMA)
       - Test quick integrity check runs on file databases
       - Test quick integrity check skipped for :memory:
       - Test corrupted database throws DB_CORRUPTED error
       - Test initializeDatabaseSafe wraps errors correctly
  </action>
  <verify>
    Run: bun test src/infrastructure/database/connection.test.ts
    All tests pass including new error handling tests.
    Verify PRAGMA busy_timeout shows 5000.
  </verify>
  <done>
    busy_timeout set to 5000ms for WAL lock handling.
    Quick integrity check runs on startup for file databases.
    Corrupted database throws appropriate error.
    All initialization errors wrapped in MemoryNexusError.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add startup integrity check to CLI</name>
  <files>
    src/presentation/cli/index.ts
  </files>
  <action>
    Add startup integrity handling to main CLI:

    1. Update CLI initialization in index.ts:
       - Import checkQuickIntegrity from health-checker
       - Import formatError from formatters
       - On database initialization failure:
         - If DB_CORRUPTED: offer to recreate
           "Database corrupted. Recreate and re-sync? (y/n)"
         - If user confirms: backup old .db file, recreate
         - If user declines: exit 1

    2. Add handleCorruptedDatabase helper:
       - Show error message
       - If TTY: prompt for recreate
       - If not TTY: show message and exit (can't prompt)
       - On recreate: mv memory.db memory.db.corrupted.{timestamp}
       - Then create fresh database

    3. Ensure startup is fast:
       - Use checkQuickIntegrity (not full integrity_check)
       - Only check when file exists (skip for new DB)
       - Don't block on prompt if not needed

    Note: This is a small targeted change to the existing CLI index.ts,
    not a full rewrite. Focus on the startup path only.
  </action>
  <verify>
    Run existing CLI tests to ensure no regressions.
    Manually test: corrupt a test database, verify prompt appears.
  </verify>
  <done>
    Startup checks database integrity.
    Corrupted database offers recreate option.
    Non-TTY gracefully exits with message.
    Startup remains fast (quick check).
  </done>
</task>

</tasks>

<verification>
1. Run: bun test src/infrastructure/database/connection.test.ts - All tests pass
2. Verify PRAGMA busy_timeout = 5000 with SELECT query
3. Verify quick_check used (not full integrity_check) for speed
4. Verify corrupted database handling works
</verification>

<success_criteria>
1. busy_timeout prevents SQLITE_BUSY errors under concurrent access
2. Quick integrity check runs fast (< 100ms for typical DB)
3. Corrupted database detected and reported
4. Recreate option works when user confirms
5. Non-TTY environments handled gracefully
6. All errors use MemoryNexusError with appropriate codes
</success_criteria>

<output>
After completion, create `.planning/phases/12-polish-error-handling/12-08-SUMMARY.md`
</output>
