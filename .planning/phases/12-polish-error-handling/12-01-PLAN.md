---
phase: 12-polish-error-handling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/domain/errors/error-codes.ts
  - src/domain/errors/memory-nexus-error.ts
  - src/domain/errors/index.ts
  - src/domain/index.ts
  - src/presentation/cli/formatters/error-formatter.ts
  - src/presentation/cli/formatters/error-formatter.test.ts
autonomous: true

must_haves:
  truths:
    - "Errors have stable codes for programmatic handling"
    - "JSON errors use structured format with code, message, context"
    - "Error messages show context (file paths, line numbers)"
    - "Red ANSI color used for errors in TTY environments"
  artifacts:
    - path: "src/domain/errors/error-codes.ts"
      provides: "ErrorCode constant with all error types"
      exports: ["ErrorCode", "ErrorCodeType"]
    - path: "src/domain/errors/memory-nexus-error.ts"
      provides: "Base error class with toJSON method"
      exports: ["MemoryNexusError"]
    - path: "src/presentation/cli/formatters/error-formatter.ts"
      provides: "Error formatting for CLI output"
      exports: ["formatError", "formatErrorJson"]
  key_links:
    - from: "src/domain/errors/memory-nexus-error.ts"
      to: "src/domain/errors/error-codes.ts"
      via: "imports ErrorCodeType"
      pattern: "import.*ErrorCodeType.*error-codes"
    - from: "src/presentation/cli/formatters/error-formatter.ts"
      to: "src/domain/errors/memory-nexus-error.ts"
      via: "formats MemoryNexusError"
      pattern: "MemoryNexusError"
---

<objective>
Implement structured error codes and error formatting infrastructure.

Purpose: Establish the foundation for consistent error handling across all CLI commands. Error codes enable programmatic handling (e.g., by scripts or Claude), while formatters ensure human-readable output in TTY and structured JSON in pipe contexts.

Output: Domain error types with stable codes, and CLI error formatters that respect output mode (default/JSON/verbose).
</objective>

<execution_context>
@C:\Users\Destiny\.claude/get-stuff-done/workflows/execute-plan.md
@C:\Users\Destiny\.claude/get-stuff-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-polish-error-handling/12-CONTEXT.md
@.planning/phases/12-polish-error-handling/12-RESEARCH.md
@src/presentation/cli/formatters/color.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create domain error codes and base error class</name>
  <files>
    src/domain/errors/error-codes.ts
    src/domain/errors/memory-nexus-error.ts
    src/domain/errors/index.ts
    src/domain/index.ts
  </files>
  <action>
    Create error infrastructure in domain layer:

    1. Create src/domain/errors/error-codes.ts:
       - Define ErrorCode constant object with all error types from CONTEXT.md:
         - DB_CONNECTION_FAILED, DB_CORRUPTED, DB_LOCKED (database errors)
         - INVALID_SESSION_ID, SESSION_NOT_FOUND (session errors)
         - SOURCE_INACCESSIBLE, DISK_FULL (file errors)
         - INVALID_JSON, UNKNOWN_FORMAT (parse errors)
         - SYNC_INTERRUPTED, SYNC_FAILED (sync errors)
         - INVALID_ARGUMENT, MISSING_ARGUMENT (CLI errors)
       - Export ErrorCodeType as union of all error codes

    2. Create src/domain/errors/memory-nexus-error.ts:
       - Create MemoryNexusError class extending Error
       - Constructor takes: code (ErrorCodeType), message (string), context? (Record<string, unknown>)
       - Add toJSON() method returning: { error: { code, message, context? } }
       - Set name property to "MemoryNexusError"

    3. Create src/domain/errors/index.ts:
       - Export all from error-codes.ts and memory-nexus-error.ts

    4. Update src/domain/index.ts:
       - Add export * from "./errors/index.js"

    Domain layer must have zero external dependencies - use only TypeScript.
  </action>
  <verify>
    Run: bun test src/domain/errors
    Verify error codes are exported correctly.
    Verify MemoryNexusError.toJSON() returns correct structure.
  </verify>
  <done>
    ErrorCode constant exists with all error types.
    MemoryNexusError class can be instantiated with code, message, context.
    toJSON() returns structured error object matching CONTEXT.md format.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CLI error formatter with tests</name>
  <files>
    src/presentation/cli/formatters/error-formatter.ts
    src/presentation/cli/formatters/error-formatter.test.ts
    src/presentation/cli/formatters/index.ts
  </files>
  <action>
    Create error formatting for CLI output:

    1. Create src/presentation/cli/formatters/error-formatter.ts:
       - Import MemoryNexusError from domain
       - Import red from ./color.js

       formatError(error: Error | MemoryNexusError, options: { verbose?: boolean }): string
       - If MemoryNexusError: format as "Error [CODE]: message"
       - If context exists: show relevant context (file path, line number, suggestion)
       - If options.verbose: include stack trace
       - Use red() for error prefix in TTY
       - Include suggestion for corrective action when applicable

       formatErrorJson(error: Error | MemoryNexusError): string
       - If MemoryNexusError: return JSON.stringify(error.toJSON())
       - If regular Error: return JSON.stringify({ error: { code: "UNKNOWN", message: error.message } })

       Helper: getSuggestion(code: ErrorCodeType): string | null
       - DB_CONNECTION_FAILED: "Check database file permissions"
       - DB_CORRUPTED: "Run 'memory doctor' to diagnose or recreate database"
       - SOURCE_INACCESSIBLE: "Check that ~/.claude/projects exists and is readable"
       - etc.

    2. Create tests in error-formatter.test.ts:
       - Test formatError with MemoryNexusError (with and without context)
       - Test formatError with regular Error
       - Test verbose mode includes stack trace
       - Test formatErrorJson returns valid JSON
       - Test getSuggestion returns appropriate suggestions
       - Test red color applied in TTY (mock process.stdout.isTTY)

    3. Update formatters/index.ts:
       - Add export * from "./error-formatter.js"
  </action>
  <verify>
    Run: bun test src/presentation/cli/formatters/error-formatter.test.ts
    All tests pass.
    Verify formatErrorJson output is valid JSON with correct structure.
  </verify>
  <done>
    formatError produces human-readable error messages with context and suggestions.
    formatErrorJson produces structured JSON for programmatic consumption.
    Verbose mode includes stack traces.
    Red color applied for errors in TTY environments.
  </done>
</task>

</tasks>

<verification>
1. Run: bun test src/domain/errors - All error domain tests pass
2. Run: bun test src/presentation/cli/formatters/error-formatter.test.ts - All formatter tests pass
3. Verify no external dependencies in domain/errors (pure TypeScript only)
4. Verify error codes match CONTEXT.md specification
</verification>

<success_criteria>
1. ErrorCode constant contains all specified error types
2. MemoryNexusError.toJSON() returns { error: { code, message, context? } } format
3. formatError shows context and suggestions appropriately
4. formatErrorJson produces valid JSON matching specification
5. All tests pass with good coverage
</success_criteria>

<output>
After completion, create `.planning/phases/12-polish-error-handling/12-01-SUMMARY.md`
</output>
