---
phase: 11-session-navigation
plan: 05
type: execute
wave: 5
depends_on: ["11-02", "11-04"]
files_modified:
  - src/application/services/llm-extractor.ts
  - src/application/services/llm-extractor.test.ts
  - src/application/services/index.ts
  - src/infrastructure/hooks/hook-runner.ts
  - src/infrastructure/hooks/hook-runner.test.ts
  - src/presentation/cli/commands/sync.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "LLM extraction produces topic entities from session content"
    - "LLM extraction produces session summary indexed in FTS5"
    - "SessionStop hook triggers LLM extraction when Claude context available"
    - "Extracted entities link to session via EntityRepository"
  artifacts:
    - path: "src/application/services/llm-extractor.ts"
      provides: "LLM-based entity extraction service"
      exports: ["LlmExtractor", "ExtractionResult"]
    - path: "src/infrastructure/hooks/hook-runner.ts"
      provides: "Enhanced hook runner with LLM extraction"
      exports: ["runHook"]
  key_links:
    - from: "src/application/services/llm-extractor.ts"
      to: "src/domain/entities/entity.ts"
      via: "Entity creation"
      pattern: "Entity.create"
    - from: "src/infrastructure/hooks/hook-runner.ts"
      to: "src/application/services/llm-extractor.ts"
      via: "LlmExtractor"
      pattern: "LlmExtractor"
---

<objective>
Implement LLM-based extraction for topics and session summaries during SessionStop hook execution.

Purpose: Enable semantic extraction of concepts and summaries that pattern matching cannot capture (EXTR-03, EXTR-04).
Output: LlmExtractor service integrated with hook runner, entities persisted via EntityRepository.
</objective>

<execution_context>
@C:\Users\Destiny\.claude/get-stuff-done/workflows/execute-plan.md
@C:\Users\Destiny\.claude/get-stuff-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-session-navigation/11-CONTEXT.md
@.planning/phases/11-session-navigation/11-02-SUMMARY.md
@src/infrastructure/hooks/hook-runner.ts
@src/domain/entities/entity.ts
@src/infrastructure/database/repositories/entity-repository.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create LlmExtractor service</name>
  <files>src/application/services/llm-extractor.ts, src/application/services/llm-extractor.test.ts, src/application/services/index.ts</files>
  <action>
Create LlmExtractor service for Claude-powered entity extraction.

Key design: LLM extraction is triggered during SessionStop hook when Claude's session context is still available. The extractor:
1. Receives session content (messages)
2. Uses structured prompts to extract topics and summary
3. Returns Entity objects for persistence

```typescript
export interface ExtractionResult {
  topics: Entity[];      // concept entities
  terms: Entity[];       // term entities
  decisions: Entity[];   // decision entities
  summary: string;       // session summary text
}

export interface LlmExtractorOptions {
  sessionId: string;
  messages: Message[];
  maxTokens?: number;  // Default 1000
}

export class LlmExtractor {
  /**
   * Extract entities from session content using LLM.
   *
   * IMPORTANT: This is designed to run during SessionStop hook
   * when Claude's session is still active. The extraction uses
   * the existing session context (no separate API call).
   *
   * Implementation approach:
   * 1. Format messages into extraction prompt
   * 2. Write prompt to temp file
   * 3. Output structured JSON with topics, terms, decisions, summary
   * 4. Parse response into Entity objects
   */
  static async extract(options: LlmExtractorOptions): Promise<ExtractionResult>;

  /**
   * Create extraction prompt for Claude.
   * Returns structured prompt requesting JSON output.
   */
  static createExtractionPrompt(messages: Message[]): string;

  /**
   * Parse LLM response into Entity objects.
   * Handles malformed JSON gracefully.
   */
  static parseExtractionResponse(
    response: string,
    sessionId: string
  ): ExtractionResult;
}
```

Extraction prompt structure:
```
Analyze this session and extract:

1. TOPICS: Key technical concepts discussed (1-5)
2. TERMS: Domain-specific terminology defined or explained (0-3)
3. DECISIONS: Explicit choices made with rationale (0-3)
4. SUMMARY: 1-2 sentence summary of what was accomplished

Output as JSON:
{
  "topics": [{ "name": "...", "confidence": 0.9 }],
  "terms": [{ "name": "...", "definition": "...", "confidence": 0.8 }],
  "decisions": [{
    "subject": "...",
    "decision": "...",
    "rejected": ["..."],
    "rationale": "...",
    "confidence": 0.9
  }],
  "summary": "..."
}
```

Entity creation from parsed response:
- Topics become 'concept' entities
- Terms become 'term' entities with definition in metadata
- Decisions become 'decision' entities with structured metadata

Tests:
1. createExtractionPrompt() formats messages correctly
2. parseExtractionResponse() handles valid JSON
3. parseExtractionResponse() handles missing fields gracefully
4. parseExtractionResponse() handles malformed JSON (returns empty result)
5. Entity confidence scores map correctly from response
6. Decision entities have complete metadata (subject, decision, rejected, rationale)
7. Term entities have definition in metadata
  </action>
  <verify>bun test src/application/services/llm-extractor.test.ts -- passes all tests</verify>
  <done>LlmExtractor service created with prompt generation and response parsing</done>
</task>

<task type="auto">
  <name>Task 2: Integrate LLM extraction into hook runner</name>
  <files>src/infrastructure/hooks/hook-runner.ts, src/infrastructure/hooks/hook-runner.test.ts</files>
  <action>
Enhance hook runner to perform LLM extraction during SessionStop.

The hook runner already handles SessionStop events. Add LLM extraction step:

```typescript
// In hook-runner.ts

import { LlmExtractor } from '../../application/services/llm-extractor.js';
import { SqliteEntityRepository } from '../database/repositories/entity-repository.js';

async function runSessionStopHook(
  sessionId: string,
  db: Database
): Promise<void> {
  // Existing sync logic...

  // New: LLM extraction (only if session has content)
  const messageRepo = new SqliteMessageRepository(db);
  const messages = await messageRepo.findBySession(sessionId);

  if (messages.length > 0) {
    try {
      const result = await LlmExtractor.extract({
        sessionId,
        messages,
      });

      // Persist extracted entities
      const entityRepo = new SqliteEntityRepository(db);

      // Save all entities
      const allEntities = [
        ...result.topics,
        ...result.terms,
        ...result.decisions,
      ];

      for (const entity of allEntities) {
        const saved = await entityRepo.save(entity);
        await entityRepo.linkToSession(saved.id!, sessionId);
      }

      // Store summary in session metadata (extend session table if needed)
      if (result.summary) {
        await sessionRepo.updateSummary(sessionId, result.summary);
      }

      logWriter.debug(`Extracted ${allEntities.length} entities from session`);
    } catch (error) {
      // LLM extraction failure should not block sync
      logWriter.warn(`LLM extraction failed: ${error}`);
    }
  }
}
```

Note: The actual LLM call mechanism depends on how Claude Code hooks work. The implementation may need to:
- Write extraction prompt to stdout (Claude reads it)
- Read structured response from stdin
- Or use a temp file exchange pattern

For now, create the integration points. The actual LLM communication may need adjustment based on Claude Code's hook execution model.

Tests (mock LlmExtractor):
1. SessionStop hook calls LlmExtractor.extract() with messages
2. Extracted entities are saved via EntityRepository
3. Entities are linked to session
4. LLM extraction errors are logged but don't fail sync
5. Empty sessions skip LLM extraction
6. Summary is stored in session record
  </action>
  <verify>bun test src/infrastructure/hooks/hook-runner.test.ts -- passes all tests</verify>
  <done>Hook runner enhanced with LLM extraction integration</done>
</task>

<task type="auto">
  <name>Task 3: Add summary field to session and FTS5 indexing</name>
  <files>src/infrastructure/database/schema.ts, src/infrastructure/database/repositories/session-repository.ts, src/infrastructure/database/repositories/session-repository.test.ts</files>
  <action>
Add summary field to sessions table and ensure it's indexed in FTS5.

Schema update:
```sql
-- Add summary column to sessions (if not exists)
ALTER TABLE sessions ADD COLUMN summary TEXT;

-- Update messages_fts to include session summary
-- (Or create separate sessions_fts virtual table)
CREATE VIRTUAL TABLE IF NOT EXISTS sessions_fts USING fts5(
    session_id,
    summary,
    content='sessions',
    content_rowid='rowid'
);

-- Trigger to keep FTS in sync
CREATE TRIGGER IF NOT EXISTS sessions_ai AFTER INSERT ON sessions BEGIN
  INSERT INTO sessions_fts(rowid, session_id, summary)
  VALUES (new.rowid, new.id, new.summary);
END;

CREATE TRIGGER IF NOT EXISTS sessions_au AFTER UPDATE ON sessions BEGIN
  DELETE FROM sessions_fts WHERE rowid = old.rowid;
  INSERT INTO sessions_fts(rowid, session_id, summary)
  VALUES (new.rowid, new.id, new.summary);
END;
```

Repository update:
```typescript
// In session-repository.ts
async updateSummary(sessionId: string, summary: string): Promise<void> {
  this.updateSummaryStmt.run(summary, sessionId);
}
```

Search service update:
```typescript
// Fts5SearchService should search sessions_fts for summary matches
// Add to search results with result type 'session_summary'
```

Tests:
1. updateSummary() persists summary to session record
2. Summary is indexed in FTS5
3. Search finds sessions by summary content
4. Summary update triggers FTS rebuild
  </action>
  <verify>bun test src/infrastructure/database/repositories/session-repository.test.ts -- passes all tests</verify>
  <done>Session summary field added with FTS5 indexing</done>
</task>

</tasks>

<verification>
- `bun test src/application/services/llm-extractor.test.ts` - Extractor tests pass
- `bun test src/infrastructure/hooks/hook-runner.test.ts` - Hook tests pass
- `bun test src/infrastructure/database/repositories/session-repository.test.ts` - Repository tests pass
- LlmExtractor exported from services/index.ts
- Manual test: SessionStop hook with --verbose shows extraction logs
</verification>

<success_criteria>
1. LlmExtractor.extract() returns structured ExtractionResult
2. Hook runner integrates LLM extraction during SessionStop
3. Extracted entities persist via EntityRepository
4. Session summary stored and indexed in FTS5
5. LLM extraction failures don't block sync
6. All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-session-navigation/11-05-SUMMARY.md`
</output>
