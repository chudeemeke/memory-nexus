# Phase 5 Plan 02: SyncService Application Layer

```yaml
wave: 2
depends_on:
  - 05-01
files_modified:
  - src/application/services/sync-service.ts
  - src/application/services/sync-service.test.ts
  - src/application/services/index.ts
  - src/application/index.ts
autonomous: true
must_haves:
  truths:
    - SyncService orchestrates session discovery, parsing, and storage
    - Incremental sync skips unchanged sessions (mtime + size check)
    - Per-session transaction boundary with error isolation
    - Progress callback invoked for each session
  artifacts:
    - SyncService class with sync() method
    - SyncOptions and SyncResult types
    - Unit tests with mocked dependencies
  key_links:
    - 05-RESEARCH.md Pattern 1 (Application Service Orchestration)
    - 05-RESEARCH.md Pattern 4 (Per-Session Transaction Boundary)
    - ROADMAP.md SYNC-02 (Incremental sync)
```

## Objective

Create SyncService application layer service that orchestrates the sync workflow: discover sessions, filter for changes, extract events, and persist to database.

## Execution Context

**Phase:** 05 - Basic Sync Command
**Wave:** 2 (Depends on 05-01 for file metadata)
**Parallelizable with:** Nothing in wave 2

## Context References

- @.planning/phases/05-basic-sync-command/05-RESEARCH.md - Patterns 1, 3, 4
- @src/infrastructure/sources/session-source.ts - FileSystemSessionSource (ISessionSource)
- @src/infrastructure/parsers/jsonl-parser.ts - JsonlEventParser (IEventParser)
- @src/domain/ports/repositories.ts - Repository interfaces
- @src/domain/ports/services.ts - ISessionSource, IEventParser interfaces

## Design

```typescript
interface SyncOptions {
  force?: boolean;           // Re-extract all sessions regardless of state
  projectFilter?: string;    // Filter by project path substring
  sessionFilter?: string;    // Sync specific session only
  onProgress?: (progress: SyncProgress) => void;
}

interface SyncProgress {
  current: number;           // Current session index (1-based)
  total: number;             // Total sessions to process
  sessionId: string;         // Current session being processed
  phase: 'discovering' | 'extracting' | 'complete';
}

interface SyncResult {
  success: boolean;
  sessionsDiscovered: number;
  sessionsProcessed: number;
  sessionsSkipped: number;   // Already up-to-date
  messagesInserted: number;
  toolUsesInserted: number;
  errors: Array<{
    sessionPath: string;
    error: string;
  }>;
  durationMs: number;
}
```

## Tasks

<task id="1">
<title>Create SyncService with sync orchestration</title>
<files>
- src/application/services/sync-service.ts
- src/application/services/sync-service.test.ts
</files>
<action>
1. Create src/application/services/ directory if needed

2. Create SyncService class:
   ```typescript
   import type { Database } from "bun:sqlite";
   import type { ISessionSource, SessionFileInfo } from "../../domain/ports/services.js";
   import type { IEventParser } from "../../domain/ports/services.js";
   import type { ISessionRepository, IMessageRepository, IToolUseRepository, IExtractionStateRepository } from "../../domain/ports/repositories.js";

   export class SyncService {
     constructor(
       private readonly sessionSource: ISessionSource,
       private readonly eventParser: IEventParser,
       private readonly sessionRepo: ISessionRepository,
       private readonly messageRepo: IMessageRepository,
       private readonly toolUseRepo: IToolUseRepository,
       private readonly extractionStateRepo: IExtractionStateRepository,
       private readonly db: Database
     ) {}

     async sync(options: SyncOptions = {}): Promise<SyncResult> { ... }
   }
   ```

3. Implement sync() method:
   - Call sessionSource.discoverSessions()
   - Apply filters (projectFilter, sessionFilter)
   - For each session, check if needs extraction (unless force=true)
   - Call onProgress callback before each session
   - Extract session in transaction
   - Track results (processed, skipped, errors)
   - Return SyncResult

4. Implement private helper methods:
   ```typescript
   private async filterSessions(sessions: SessionFileInfo[], options: SyncOptions): Promise<SessionFileInfo[]>
   private needsExtraction(session: SessionFileInfo, existingState: ExtractionState | null, force: boolean): boolean
   private async extractSession(session: SessionFileInfo): Promise<{ messages: number; toolUses: number }>
   ```

5. Write unit tests with mocked dependencies:
   - Test sync discovers sessions
   - Test projectFilter filters by path substring
   - Test sessionFilter filters by session ID
   - Test force=true processes all sessions
   - Test incremental sync skips unchanged sessions (same mtime+size)
   - Test incremental sync processes changed sessions (different mtime or size)
   - Test error in one session doesn't affect others
   - Test onProgress callback called for each session
   - Test SyncResult has correct counts
</action>
<verify>
```bash
bun test src/application/services/sync-service.test.ts
```
All tests pass.
</verify>
<done>
SyncService implements sync orchestration with filtering, incremental detection, and progress callbacks.
</done>
</task>

<task id="2">
<title>Implement incremental sync detection</title>
<files>
- src/application/services/sync-service.ts
- src/application/services/sync-service.test.ts
</files>
<action>
1. Implement needsExtraction() method:
   ```typescript
   private needsExtraction(
     session: SessionFileInfo,
     existingState: ExtractionState | null,
     force: boolean
   ): boolean {
     if (force) return true;
     if (!existingState) return true;
     if (existingState.status !== "complete") return true;

     // Compare file metadata
     const storedMtime = existingState.fileMtime;
     const storedSize = existingState.fileSize;

     if (!storedMtime || storedSize === undefined) return true;

     return (
       session.modifiedTime.getTime() !== storedMtime.getTime() ||
       session.size !== storedSize
     );
   }
   ```

2. Update filterSessions() to use needsExtraction():
   ```typescript
   private async filterSessions(
     sessions: SessionFileInfo[],
     options: SyncOptions
   ): Promise<SessionFileInfo[]> {
     let filtered = sessions;

     // Apply projectFilter
     if (options.projectFilter) {
       filtered = filtered.filter(s =>
         s.projectPath.decoded.includes(options.projectFilter!)
       );
     }

     // Apply sessionFilter
     if (options.sessionFilter) {
       filtered = filtered.filter(s => s.id === options.sessionFilter);
     }

     // Check extraction state (unless force)
     const toProcess: SessionFileInfo[] = [];
     for (const session of filtered) {
       const state = await this.extractionStateRepo.findBySessionPath(session.path);
       if (this.needsExtraction(session, state, options.force ?? false)) {
         toProcess.push(session);
       }
     }

     return toProcess;
   }
   ```

3. Add tests for edge cases:
   - Session with null mtime in extraction state triggers re-extraction
   - Session with null size in extraction state triggers re-extraction
   - Session with "error" status triggers re-extraction
   - Session with "in_progress" status triggers re-extraction
</action>
<verify>
```bash
bun test src/application/services/sync-service.test.ts --grep "incremental"
```
Incremental sync tests pass.
</verify>
<done>
Incremental sync detection compares mtime and size, handles edge cases.
</done>
</task>

<task id="3">
<title>Implement per-session extraction with transaction safety</title>
<files>
- src/application/services/sync-service.ts
- src/application/services/sync-service.test.ts
</files>
<action>
1. Implement extractSession() method:
   ```typescript
   private async extractSession(
     session: SessionFileInfo
   ): Promise<{ messages: number; toolUses: number }> {
     // Create pending extraction state
     const stateId = crypto.randomUUID();
     let state = ExtractionState.create({
       id: stateId,
       sessionPath: session.path,
       startedAt: new Date(),
       status: "pending",
     }).withFileMetadata(session.modifiedTime, session.size);

     try {
       // Parse events
       const events: ParsedEvent[] = [];
       for await (const event of this.eventParser.parse(session.path)) {
         events.push(event);
       }

       // Extract messages and tool uses
       const messages = extractMessages(events, session.id);
       const toolUses = extractToolUses(events, session.id);

       // Create session entity
       const sessionEntity = Session.create({
         id: session.id,
         projectPath: session.projectPath,
         startedAt: /* from first event */,
         lastActivityAt: /* from last event */,
         messageCount: messages.length,
         toolUseCount: toolUses.length,
       });

       // Transaction: save all data atomically
       const commitSession = this.db.transaction(() => {
         this.sessionRepo.save(sessionEntity);
         this.messageRepo.saveMany(messages.map(m => ({ message: m, sessionId: session.id })));
         this.toolUseRepo.saveMany(toolUses.map(t => ({ toolUse: t, sessionId: session.id })));

         const completedState = state
           .startProcessing()
           .incrementMessages(messages.length)
           .complete(new Date());
         this.extractionStateRepo.save(completedState);
       });

       commitSession.immediate();

       return { messages: messages.length, toolUses: toolUses.length };
     } catch (error) {
       // Save error state (separate transaction)
       const errorState = state.fail(error instanceof Error ? error.message : String(error));
       await this.extractionStateRepo.save(errorState);
       throw error;
     }
   }
   ```

2. Add helper functions for extracting messages and tool uses from parsed events (or import from existing infrastructure)

3. Add tests:
   - Successful extraction saves session, messages, tool uses, and complete state
   - Failed extraction saves error state
   - Transaction rollback on error (messages not saved if commit fails)
   - File metadata is saved in extraction state
</action>
<verify>
```bash
bun test src/application/services/sync-service.test.ts --grep "extract"
```
Extraction tests pass.
</verify>
<done>
Per-session extraction uses transaction for atomicity. Error state saved on failure.
</done>
</task>

<task id="4">
<title>Create application layer barrel exports</title>
<files>
- src/application/services/index.ts
- src/application/index.ts
</files>
<action>
1. Create src/application/services/index.ts:
   ```typescript
   export { SyncService } from "./sync-service.js";
   export type { SyncOptions, SyncProgress, SyncResult } from "./sync-service.js";
   ```

2. Create or update src/application/index.ts:
   ```typescript
   export * from "./services/index.js";
   ```

3. Run full test suite to verify exports work
</action>
<verify>
```bash
bun test
```
All tests pass. SyncService is exported from application layer.
</verify>
<done>
Application layer barrel exports created. SyncService accessible from src/application.
</done>
</task>

## Verification

```bash
# All application layer tests pass
bun test src/application/

# Full test suite passes
bun test
```

## Success Criteria

- [ ] SyncService accepts all required dependencies via constructor
- [ ] sync() discovers sessions and returns SyncResult
- [ ] projectFilter filters by path substring
- [ ] sessionFilter filters by session ID
- [ ] force=true processes all sessions
- [ ] Incremental sync compares mtime and size
- [ ] Sessions with incomplete/error state are re-extracted
- [ ] Per-session transaction ensures atomicity
- [ ] Error in one session doesn't affect others
- [ ] onProgress callback invoked for each session
- [ ] Application layer barrel exports work
