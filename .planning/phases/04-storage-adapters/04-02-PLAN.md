---
phase: 04-storage-adapters
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/infrastructure/database/repositories/message-repository.ts
  - src/infrastructure/database/repositories/message-repository.test.ts
autonomous: true

must_haves:
  truths:
    - "Messages can be saved with session association"
    - "Messages are automatically indexed for full-text search"
    - "Batch insert of 1000 messages completes in under 5 seconds"
    - "Duplicate messages are skipped without error"
  artifacts:
    - path: "src/infrastructure/database/repositories/message-repository.ts"
      provides: "IMessageRepository implementation with batch support"
      exports: ["SqliteMessageRepository"]
  key_links:
    - from: "SqliteMessageRepository.saveMany"
      to: "messages_meta table"
      via: "db.transaction().immediate() with batched inserts"
      pattern: "db\\.transaction\\("
    - from: "messages_meta INSERT"
      to: "messages_fts"
      via: "FTS5 trigger (automatic)"
      pattern: "messages_fts_insert"
---

<objective>
Implement SqliteMessageRepository with batch write support and FTS5 integration.

Purpose: Messages are the primary content for search. The repository must handle bulk inserts efficiently (1000+ messages) while FTS5 triggers maintain the search index automatically.

Output: Message repository implementing IMessageRepository with batch write capability, including progress callback support for CLI integration.
</objective>

<execution_context>
@~/.claude/get-stuff-done/workflows/execute-plan.md
@~/.claude/get-stuff-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-storage-adapters/04-CONTEXT.md
@.planning/phases/04-storage-adapters/04-RESEARCH.md

@src/domain/ports/repositories.ts
@src/domain/entities/message.ts
@src/infrastructure/database/schema.ts
@src/infrastructure/database/connection.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement SqliteMessageRepository core methods</name>
  <files>
    src/infrastructure/database/repositories/message-repository.ts
    src/infrastructure/database/repositories/message-repository.test.ts
  </files>
  <action>
Create SqliteMessageRepository implementing IMessageRepository:

1. Constructor accepts Database instance, creates prepared statements:
   - findByIdStmt: SELECT by id from messages_meta
   - findBySessionStmt: SELECT WHERE session_id ORDER BY timestamp
   - insertStmt: INSERT OR IGNORE into messages_meta

2. Implement interface methods:
   - findById(id): Returns Message | null
   - findBySession(sessionId): Returns Message[], ordered by timestamp ascending
   - save(message, sessionId): Single insert with INSERT OR IGNORE

3. Row mapping:
   - Message.create() requires: id, role, content, timestamp, toolUseIds (optional)
   - DB columns: id, session_id, role, content, timestamp, tool_use_ids (JSON string or null)
   - Parse tool_use_ids from JSON on read, stringify on write

4. FTS5 indexing is automatic via trigger (no manual FTS insert needed).

Write tests covering:
- save and findById round-trip
- findBySession returns messages in timestamp order
- INSERT OR IGNORE on duplicate ID (no error)
- Role constraint validation ('user' or 'assistant' only)
- tool_use_ids JSON serialization/deserialization
  </action>
  <verify>
Run `bun test src/infrastructure/database/repositories/message-repository.test.ts` - core method tests pass.
  </verify>
  <done>
SqliteMessageRepository implements findById, findBySession, and save methods with proper row mapping and INSERT OR IGNORE idempotency.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement batch saveMany with progress callback</name>
  <files>
    src/infrastructure/database/repositories/message-repository.ts
    src/infrastructure/database/repositories/message-repository.test.ts
  </files>
  <action>
Add saveMany method with batch processing (per CONTEXT.md decisions):

1. Define BatchResult interface:
```typescript
interface BatchResult {
  inserted: number;
  skipped: number;
  errors: Array<{ id: string; reason: string }>;
}

interface BatchOptions {
  onProgress?: (progress: { inserted: number; total: number }) => void;
}
```

2. Implement saveMany(messages, options?):
   - Batch size: 100 messages (hardcoded per CONTEXT.md)
   - Wrap each batch in db.transaction().immediate()
   - Within transaction, iterate and INSERT OR IGNORE each message
   - Catch per-message errors, log to errors array, continue
   - Call onProgress callback after each batch completes
   - Return BatchResult with totals

3. Implementation pattern:
```typescript
async saveMany(
  messages: Array<{ message: Message; sessionId: string }>,
  options?: BatchOptions
): Promise<BatchResult> {
  const BATCH_SIZE = 100;
  const result: BatchResult = { inserted: 0, skipped: 0, errors: [] };

  for (let i = 0; i < messages.length; i += BATCH_SIZE) {
    const batch = messages.slice(i, i + BATCH_SIZE);

    const insertBatch = this.db.transaction((items: typeof batch) => {
      for (const { message, sessionId } of items) {
        try {
          const changes = this.insertStmt.run({ /* params */ }).changes;
          if (changes > 0) {
            result.inserted++;
          } else {
            result.skipped++;  // Duplicate, INSERT OR IGNORE
          }
        } catch (err) {
          result.skipped++;
          result.errors.push({
            id: message.id,
            reason: err instanceof Error ? err.message : String(err),
          });
        }
      }
    });

    insertBatch.immediate(batch);
    options?.onProgress?.({ inserted: result.inserted, total: messages.length });
  }

  return result;
}
```

Write tests covering:
- saveMany with 10 messages (single batch)
- saveMany with 250 messages (multiple batches)
- saveMany with 1000 messages completes in < 5 seconds
- Progress callback receives correct values
- Partial failure (one bad message) doesn't fail batch
- Duplicate handling (re-saving same messages returns skipped count)
  </action>
  <verify>
Run `bun test src/infrastructure/database/repositories/message-repository.test.ts` - batch tests pass, performance test confirms < 5 seconds for 1000 messages.
  </verify>
  <done>
saveMany processes messages in batches of 100, uses immediate transactions, reports progress via callback, and handles partial failures gracefully. Performance verified at < 5 seconds for 1000 messages.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify FTS5 indexing via triggers</name>
  <files>
    src/infrastructure/database/repositories/message-repository.test.ts
  </files>
  <action>
Add integration tests verifying FTS5 automatic indexing:

1. Test that inserted messages appear in FTS5 index:
   - Insert a message via repository
   - Query messages_fts directly with MATCH
   - Verify message content is found

2. Test FTS5 trigger correctness:
   - Insert message
   - Query: `SELECT rowid FROM messages_fts WHERE messages_fts MATCH $query`
   - Verify rowid matches messages_meta.rowid

3. Test EXPLAIN QUERY PLAN shows FTS5 usage:
   - Run EXPLAIN QUERY PLAN on a MATCH query
   - Verify output contains "SCAN messages_fts"

Note: These tests validate the schema triggers from Phase 2 work correctly with the repository. They don't test FTS5 itself, just that our INSERT triggers the index update.
  </action>
  <verify>
Run `bun test src/infrastructure/database/repositories/message-repository.test.ts` - FTS5 integration tests pass.
  </verify>
  <done>
FTS5 triggers verified: messages inserted via repository are automatically indexed and searchable via MATCH queries.
  </done>
</task>

</tasks>

<verification>
Phase requirements addressed:
- STOR-02: SqliteMessageRepository implementing IMessageRepository with FTS5 (Tasks 1, 3)
- STOR-06: Batch database writes with configurable batch size (Task 2)

Run verification commands:
```bash
# Unit tests pass
bun test src/infrastructure/database/repositories/message-repository.test.ts

# Performance test
bun test --test-name-pattern "1000 messages"

# Verify FTS5 MATCH works
bun test --test-name-pattern "FTS5"
```
</verification>

<success_criteria>
1. SqliteMessageRepository passes all interface contract tests
2. saveMany inserts 1000 messages in under 5 seconds
3. Progress callback receives accurate progress updates
4. INSERT OR IGNORE handles duplicates gracefully (no errors, returns skipped count)
5. FTS5 index is automatically updated on insert (verified via MATCH query)
6. Partial batch failures don't stop entire operation
</success_criteria>

<output>
After completion, create `.planning/phases/04-storage-adapters/04-02-SUMMARY.md`
</output>
