---
phase: 04-storage-adapters
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/infrastructure/database/repositories/session-repository.ts
  - src/infrastructure/database/repositories/session-repository.test.ts
  - src/infrastructure/database/repositories/extraction-state-repository.ts
  - src/infrastructure/database/repositories/extraction-state-repository.test.ts
  - src/infrastructure/database/repositories/index.ts
autonomous: true

must_haves:
  truths:
    - "Sessions can be saved and retrieved by ID"
    - "Sessions can be queried by project path"
    - "Extraction states track sync progress per session"
    - "Incomplete sessions auto-retry on next sync"
  artifacts:
    - path: "src/infrastructure/database/repositories/session-repository.ts"
      provides: "ISessionRepository implementation"
      exports: ["SqliteSessionRepository"]
    - path: "src/infrastructure/database/repositories/extraction-state-repository.ts"
      provides: "IExtractionStateRepository implementation"
      exports: ["SqliteExtractionStateRepository"]
  key_links:
    - from: "SqliteSessionRepository"
      to: "sessions table"
      via: "prepared statements with INSERT OR IGNORE"
      pattern: "INSERT OR IGNORE INTO sessions"
    - from: "SqliteExtractionStateRepository"
      to: "extraction_state table"
      via: "prepared statements"
      pattern: "INSERT OR REPLACE INTO extraction_state"
---

<objective>
Implement SqliteSessionRepository and SqliteExtractionStateRepository adapters.

Purpose: Sessions are the root aggregate - all other entities reference sessions. Extraction state tracks incremental sync progress. Both are needed before messages can be stored.

Output: Two repository classes implementing ISessionRepository and IExtractionStateRepository ports, with unit tests validating all interface methods.
</objective>

<execution_context>
@~/.claude/get-stuff-done/workflows/execute-plan.md
@~/.claude/get-stuff-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-storage-adapters/04-CONTEXT.md
@.planning/phases/04-storage-adapters/04-RESEARCH.md

@src/domain/ports/repositories.ts
@src/domain/entities/session.ts
@src/domain/entities/extraction-state.ts
@src/domain/value-objects/project-path.ts
@src/infrastructure/database/schema.ts
@src/infrastructure/database/connection.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement SqliteSessionRepository</name>
  <files>
    src/infrastructure/database/repositories/session-repository.ts
    src/infrastructure/database/repositories/session-repository.test.ts
  </files>
  <action>
Create SqliteSessionRepository implementing ISessionRepository:

1. Constructor accepts Database instance, creates prepared statements:
   - findByIdStmt: SELECT by id
   - findByProjectStmt: SELECT by project_path_encoded
   - findRecentStmt: SELECT ORDER BY start_time DESC LIMIT ?
   - insertStmt: INSERT OR IGNORE (idempotent)
   - deleteStmt: DELETE by id

2. Implement interface methods:
   - findById(id): Returns Session | null, maps DB row to Session.create()
   - findByProject(projectPath): Uses projectPath.encoded for WHERE clause
   - findRecent(limit): ORDER BY start_time DESC LIMIT n
   - save(session): Uses INSERT OR IGNORE, maps Session to row params
   - saveMany(sessions): Wrap in db.transaction().immediate()
   - delete(id): Simple DELETE, cascade handled by FK

3. Row mapping:
   - Session.create() requires: id, projectPath (ProjectPath.fromEncoded), startTime (new Date), endTime (optional)
   - DB columns: id, project_path_encoded, project_path_decoded, project_name, start_time, end_time, message_count

4. Use named parameters ($id, $projectPath, etc) not positional.

Write tests covering:
- save and findById round-trip
- findByProject filtering
- findRecent ordering and limit
- saveMany bulk insert (10+ sessions)
- delete removes session
- INSERT OR IGNORE on duplicate ID (no error, no update)
  </action>
  <verify>
Run `bun test src/infrastructure/database/repositories/session-repository.test.ts` - all tests pass.
  </verify>
  <done>
SqliteSessionRepository implements all ISessionRepository methods. Tests verify save/find/delete operations work correctly with INSERT OR IGNORE idempotency.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement SqliteExtractionStateRepository</name>
  <files>
    src/infrastructure/database/repositories/extraction-state-repository.ts
    src/infrastructure/database/repositories/extraction-state-repository.test.ts
  </files>
  <action>
Create SqliteExtractionStateRepository implementing IExtractionStateRepository:

1. Constructor accepts Database instance, creates prepared statements:
   - findByIdStmt: SELECT by id
   - findBySessionPathStmt: SELECT by session_path
   - findPendingStmt: SELECT WHERE status IN ('pending', 'in_progress')
   - saveStmt: INSERT OR REPLACE (upsert semantics)

2. Implement interface methods:
   - findById(id): Returns ExtractionState | null
   - findBySessionPath(sessionPath): Used to check if already extracted
   - findPending(): Returns states that need processing
   - save(state): Uses INSERT OR REPLACE for upsert

3. Row mapping:
   - ExtractionState.create() requires: id, sessionPath, startedAt, status (optional), completedAt (optional), messagesExtracted (optional), errorMessage (optional)
   - DB columns: id, session_path, started_at, status, completed_at, messages_extracted, error_message, file_mtime, file_size

4. Transaction-based state updates (CONTEXT.md decision):
   - save() is called within the same transaction as message inserts
   - State is ONLY marked 'complete' after data commit succeeds
   - Use INSERT OR REPLACE for idempotent saves

Write tests covering:
- save and findById round-trip
- findBySessionPath lookup
- findPending returns pending/in_progress, not complete/error
- State progression: pending -> in_progress -> complete
- State progression: pending -> in_progress -> error
- INSERT OR REPLACE updates existing state
  </action>
  <verify>
Run `bun test src/infrastructure/database/repositories/extraction-state-repository.test.ts` - all tests pass.
  </verify>
  <done>
SqliteExtractionStateRepository implements all IExtractionStateRepository methods. Tests verify state tracking and upsert semantics work correctly.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create repository index and run full test suite</name>
  <files>
    src/infrastructure/database/repositories/index.ts
    src/infrastructure/database/index.ts
  </files>
  <action>
1. Create src/infrastructure/database/repositories/index.ts:
   - Export SqliteSessionRepository
   - Export SqliteExtractionStateRepository

2. Update src/infrastructure/database/index.ts:
   - Add export * from "./repositories/index.js"

3. Run full test suite to verify no regressions.
  </action>
  <verify>
Run `bun test` - all tests pass (462+ existing tests plus new tests).
  </verify>
  <done>
Repository exports are configured. Full test suite passes with no regressions.
  </done>
</task>

</tasks>

<verification>
Phase requirements addressed:
- STOR-01: SqliteSessionRepository implementing ISessionRepository (Task 1)
- STOR-07: Transaction-based extraction state updates (Task 2 - INSERT OR REPLACE semantics)

Run verification commands:
```bash
# Unit tests pass
bun test src/infrastructure/database/repositories/

# Full suite has no regressions
bun test

# Check coverage
bun test --coverage
```
</verification>

<success_criteria>
1. SqliteSessionRepository passes all interface contract tests
2. SqliteExtractionStateRepository passes all interface contract tests
3. INSERT OR IGNORE prevents duplicate errors on sessions
4. INSERT OR REPLACE enables idempotent state updates
5. All existing tests continue to pass (no regressions)
6. Coverage remains above 95% at each metric
</success_criteria>

<output>
After completion, create `.planning/phases/04-storage-adapters/04-01-SUMMARY.md`
</output>
