---
phase: 10-hook-integration
plan: 03
type: execute
wave: 2
depends_on: ["10-01", "10-02"]
files_modified:
  - src/infrastructure/hooks/settings-manager.ts
  - src/infrastructure/hooks/settings-manager.test.ts
  - src/presentation/cli/commands/install.ts
  - src/presentation/cli/commands/install.test.ts
  - src/presentation/cli/commands/uninstall.ts
  - src/presentation/cli/commands/uninstall.test.ts
  - src/presentation/cli/commands/status.ts
  - src/presentation/cli/commands/status.test.ts
  - src/presentation/cli/commands/index.ts
  - src/presentation/cli/index.ts
autonomous: true

must_haves:
  truths:
    - "Install command adds hooks to Claude Code settings.json"
    - "Install command backs up existing settings before modifying"
    - "Install command copies hook script to ~/.memory-nexus/hooks/"
    - "Uninstall command removes hooks from settings.json"
    - "Uninstall command can restore from backup"
    - "Status command shows hook installation state"
    - "Status command shows config values"
    - "Status command shows pending session count"
  artifacts:
    - path: "src/infrastructure/hooks/settings-manager.ts"
      provides: "Claude Code settings.json manipulation"
      exports: ["installHooks", "uninstallHooks", "checkHooksInstalled"]
    - path: "src/presentation/cli/commands/install.ts"
      provides: "aidev memory install command"
      exports: ["createInstallCommand"]
    - path: "src/presentation/cli/commands/uninstall.ts"
      provides: "aidev memory uninstall command"
      exports: ["createUninstallCommand"]
    - path: "src/presentation/cli/commands/status.ts"
      provides: "aidev memory status command"
      exports: ["createStatusCommand"]
  key_links:
    - from: "settings-manager.ts"
      to: "~/.claude/settings.json"
      via: "readFileSync/writeFileSync"
      pattern: "settings\\.json"
    - from: "install.ts"
      to: "settings-manager.ts installHooks"
      via: "function call"
      pattern: "installHooks"
    - from: "status.ts"
      to: "config-manager.ts loadConfig"
      via: "function call"
      pattern: "loadConfig"
---

<objective>
Create CLI commands for hook installation, uninstallation, and status display.

Purpose: Users need to install hooks into Claude Code settings, check installation status, and cleanly remove hooks if needed. The install command safely modifies ~/.claude/settings.json with backup, copies the hook script, and validates the installation. Status command provides visibility into hook state and configuration.

Output: Working install, uninstall, and status commands integrated into the CLI.
</objective>

<execution_context>
@C:\Users\Destiny\.claude/get-stuff-done/workflows/execute-plan.md
@C:\Users\Destiny\.claude/get-stuff-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-hook-integration/10-CONTEXT.md
@.planning/phases/10-hook-integration/10-RESEARCH.md
@.planning/phases/10-hook-integration/10-01-PLAN.md
@.planning/phases/10-hook-integration/10-02-PLAN.md

@src/presentation/cli/commands/sync.ts
@src/presentation/cli/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create settings-manager for Claude Code settings manipulation</name>
  <files>
    src/infrastructure/hooks/settings-manager.ts
    src/infrastructure/hooks/settings-manager.test.ts
    src/infrastructure/hooks/index.ts
  </files>
  <action>
Create settings-manager.ts for safe manipulation of Claude Code settings:

1. Define types for Claude Code settings:
```typescript
interface HookEntry {
  type: "command";
  command: string;
  timeout?: number;
}

interface HookConfig {
  matcher?: string;  // For PreCompact: "auto" or "manual"
  hooks: HookEntry[];
}

interface ClaudeSettings {
  hooks?: {
    SessionEnd?: HookConfig[];
    PreCompact?: HookConfig[];
    [key: string]: HookConfig[] | undefined;
  };
  [key: string]: unknown;
}
```

2. Implement path helpers:
```typescript
export function getClaudeSettingsPath(): string {
  return join(homedir(), ".claude", "settings.json");
}

export function getBackupPath(): string {
  return join(homedir(), ".memory-nexus", "backups", "settings.json.backup");
}

export function getHookScriptPath(): string {
  return join(homedir(), ".memory-nexus", "hooks", "sync-hook.js");
}
```

3. Implement backupSettings():
- Read current settings.json
- Write to ~/.memory-nexus/backups/settings.json.backup
- Create backup directory if needed
- Return true on success, false if settings don't exist

4. Implement restoreFromBackup():
- Check if backup exists
- If exists, copy backup to settings.json
- Return true on success, false if no backup

5. Implement installHooks():
```typescript
export function installHooks(): { success: boolean; message: string } {
  const settingsPath = getClaudeSettingsPath();
  const hookScriptPath = getHookScriptPath();

  // Backup existing settings
  backupSettings();

  // Read existing settings or create new
  let settings: ClaudeSettings = {};
  if (existsSync(settingsPath)) {
    settings = JSON.parse(readFileSync(settingsPath, "utf-8"));
  }

  // Build hook command (use forward slashes for Windows JSON compatibility)
  const command = `bun run "${hookScriptPath.replace(/\\/g, "/")}"`;

  // Initialize hooks object if missing
  settings.hooks = settings.hooks ?? {};

  // Check if already installed
  const memoryNexusMarker = "memory-nexus";
  const alreadyInstalled = settings.hooks.SessionEnd?.some(
    (h) => h.hooks.some((e) => e.command.includes(memoryNexusMarker))
  );

  if (alreadyInstalled) {
    return { success: true, message: "Hooks already installed" };
  }

  // Add SessionEnd hook
  settings.hooks.SessionEnd = settings.hooks.SessionEnd ?? [];
  settings.hooks.SessionEnd.push({
    hooks: [{
      type: "command",
      command,
      timeout: 5,
    }],
  });

  // Add PreCompact hook
  settings.hooks.PreCompact = settings.hooks.PreCompact ?? [];
  settings.hooks.PreCompact.push({
    matcher: "auto",  // Only on automatic compaction
    hooks: [{
      type: "command",
      command,
      timeout: 5,
    }],
  });

  // Write updated settings
  mkdirSync(dirname(settingsPath), { recursive: true });
  writeFileSync(settingsPath, JSON.stringify(settings, null, 2));

  return { success: true, message: "Hooks installed successfully" };
}
```

6. Implement uninstallHooks():
- Read current settings
- Filter out memory-nexus hooks from SessionEnd and PreCompact
- Write updated settings
- Optionally restore from backup if --restore flag

7. Implement checkHooksInstalled():
```typescript
export interface HookStatus {
  sessionEnd: boolean;
  preCompact: boolean;
  hookScriptExists: boolean;
  backupExists: boolean;
}

export function checkHooksInstalled(): HookStatus {
  const settings = loadClaudeSettings();
  const hookScriptPath = getHookScriptPath();
  const backupPath = getBackupPath();

  const memoryNexusMarker = "memory-nexus";

  return {
    sessionEnd: settings.hooks?.SessionEnd?.some(
      (h) => h.hooks.some((e) => e.command.includes(memoryNexusMarker))
    ) ?? false,
    preCompact: settings.hooks?.PreCompact?.some(
      (h) => h.hooks.some((e) => e.command.includes(memoryNexusMarker))
    ) ?? false,
    hookScriptExists: existsSync(hookScriptPath),
    backupExists: existsSync(backupPath),
  };
}
```

Tests should cover:
- installHooks creates hooks in settings.json
- installHooks backs up existing settings
- installHooks is idempotent (won't duplicate)
- uninstallHooks removes memory-nexus hooks
- uninstallHooks preserves other hooks
- checkHooksInstalled detects installed hooks
- checkHooksInstalled returns false when not installed
- Windows paths converted to forward slashes in command

Update hooks/index.ts to export settings-manager functions.
  </action>
  <verify>
Run `bun test settings-manager` - all tests pass
  </verify>
  <done>
settings-manager safely manipulates Claude Code settings with backup/restore and hook detection
  </done>
</task>

<task type="auto">
  <name>Task 2: Create install and uninstall CLI commands</name>
  <files>
    src/presentation/cli/commands/install.ts
    src/presentation/cli/commands/install.test.ts
    src/presentation/cli/commands/uninstall.ts
    src/presentation/cli/commands/uninstall.test.ts
  </files>
  <action>
Create install.ts command:

```typescript
import { Command } from "commander";
import { copyFileSync, mkdirSync, existsSync } from "node:fs";
import { join, dirname } from "node:path";
import { homedir } from "node:os";
import {
  installHooks,
  checkHooksInstalled,
  getHookScriptPath,
} from "../../../infrastructure/hooks/index.js";

interface InstallOptions {
  force?: boolean;
}

export function createInstallCommand(): Command {
  return new Command("install")
    .description("Install Claude Code hooks for automatic session sync")
    .option("-f, --force", "Reinstall even if already installed")
    .action(async (options: InstallOptions) => {
      await executeInstallCommand(options);
    });
}

export async function executeInstallCommand(options: InstallOptions): Promise<void> {
  const status = checkHooksInstalled();

  // Check if already installed
  if (status.sessionEnd && status.preCompact && !options.force) {
    console.log("Hooks are already installed.");
    console.log("Use --force to reinstall.");
    return;
  }

  // Copy hook script to ~/.memory-nexus/hooks/
  const hookScriptDest = getHookScriptPath();
  mkdirSync(dirname(hookScriptDest), { recursive: true });

  // Find built hook script (from package or relative path)
  const hookScriptSrc = findHookScriptSource();
  if (!hookScriptSrc) {
    console.error("Error: Hook script not found. Run 'bun run build:hook' first.");
    process.exitCode = 1;
    return;
  }

  copyFileSync(hookScriptSrc, hookScriptDest);
  console.log(`Copied hook script to ${hookScriptDest}`);

  // Install hooks into settings.json
  const result = installHooks();
  console.log(result.message);

  if (result.success) {
    console.log("\nHook installation complete!");
    console.log("Sessions will now sync automatically when they end.");
    console.log("\nTo check status: aidev memory status");
    console.log("To uninstall: aidev memory uninstall");
  } else {
    process.exitCode = 1;
  }
}

function findHookScriptSource(): string | null {
  const candidates = [
    join(__dirname, "../../../../dist/sync-hook.js"),
    join(process.cwd(), "dist/sync-hook.js"),
  ];
  return candidates.find((p) => existsSync(p)) ?? null;
}
```

Create uninstall.ts command:

```typescript
import { Command } from "commander";
import { unlinkSync, existsSync } from "node:fs";
import {
  uninstallHooks,
  checkHooksInstalled,
  getHookScriptPath,
  restoreFromBackup,
} from "../../../infrastructure/hooks/index.js";

interface UninstallOptions {
  restore?: boolean;
}

export function createUninstallCommand(): Command {
  return new Command("uninstall")
    .description("Remove Claude Code hooks for automatic session sync")
    .option("-r, --restore", "Restore settings.json from backup")
    .action(async (options: UninstallOptions) => {
      await executeUninstallCommand(options);
    });
}

export async function executeUninstallCommand(options: UninstallOptions): Promise<void> {
  const status = checkHooksInstalled();

  if (!status.sessionEnd && !status.preCompact) {
    console.log("Hooks are not installed.");
    return;
  }

  if (options.restore && status.backupExists) {
    const restored = restoreFromBackup();
    if (restored) {
      console.log("Restored settings.json from backup.");
    }
  } else {
    const result = uninstallHooks();
    console.log(result.message);
  }

  // Remove hook script
  const hookScriptPath = getHookScriptPath();
  if (existsSync(hookScriptPath)) {
    unlinkSync(hookScriptPath);
    console.log("Removed hook script.");
  }

  console.log("\nHooks uninstalled successfully.");
  console.log("Sessions will no longer sync automatically.");
  console.log("Manual sync still available: aidev memory sync");
}
```

Tests should cover:
- Install creates hook script in ~/.memory-nexus/hooks/
- Install adds hooks to settings.json
- Install is idempotent without --force
- Install --force reinstalls
- Uninstall removes hooks from settings.json
- Uninstall removes hook script file
- Uninstall --restore uses backup file
  </action>
  <verify>
Run `bun test install` - all tests pass
Run `bun test uninstall` - all tests pass
  </verify>
  <done>
install and uninstall commands work correctly with proper backup/restore and file management
  </done>
</task>

<task type="auto">
  <name>Task 3: Create status command and wire all commands to CLI</name>
  <files>
    src/presentation/cli/commands/status.ts
    src/presentation/cli/commands/status.test.ts
    src/presentation/cli/commands/index.ts
    src/presentation/cli/index.ts
  </files>
  <action>
Create status.ts command:

```typescript
import { Command, Option } from "commander";
import {
  loadConfig,
  checkHooksInstalled,
  readRecentLogs,
  type HookStatus,
  type MemoryNexusConfig,
} from "../../../infrastructure/hooks/index.js";
import {
  initializeDatabase,
  closeDatabase,
  getDefaultDbPath,
  SqliteExtractionStateRepository,
  SqliteSessionRepository,
} from "../../../infrastructure/database/index.js";
import { FileSystemSessionSource } from "../../../infrastructure/sources/index.js";

interface StatusOptions {
  json?: boolean;
}

interface StatusInfo {
  hooks: HookStatus;
  config: MemoryNexusConfig;
  lastSync: string | null;
  pendingSessions: number;
  recentLogs: number;
}

export function createStatusCommand(): Command {
  return new Command("status")
    .description("Show hook installation status and configuration")
    .option("--json", "Output as JSON")
    .action(async (options: StatusOptions) => {
      await executeStatusCommand(options);
    });
}

export async function executeStatusCommand(options: StatusOptions): Promise<void> {
  const status = await gatherStatus();

  if (options.json) {
    console.log(JSON.stringify(status, null, 2));
    return;
  }

  formatStatusOutput(status);
}

async function gatherStatus(): Promise<StatusInfo> {
  const hooks = checkHooksInstalled();
  const config = loadConfig();
  const logs = readRecentLogs(1);  // Get most recent log entry

  // Get pending sessions count
  let pendingSessions = 0;
  try {
    const dbPath = getDefaultDbPath();
    const { db } = initializeDatabase({ path: dbPath });
    try {
      const sessionSource = new FileSystemSessionSource();
      const extractionStateRepo = new SqliteExtractionStateRepository(db);

      const allSessions = await sessionSource.discoverSessions();
      for (const session of allSessions) {
        const state = await extractionStateRepo.findBySessionPath(session.path);
        if (!state || state.status !== "complete") {
          pendingSessions++;
        }
      }
    } finally {
      closeDatabase(db);
    }
  } catch {
    // Database may not exist yet
  }

  return {
    hooks,
    config,
    lastSync: logs.length > 0 ? logs[0].timestamp : null,
    pendingSessions,
    recentLogs: readRecentLogs(100).length,
  };
}

function formatStatusOutput(status: StatusInfo): void {
  console.log("Memory-Nexus Status");
  console.log("===================\n");

  console.log("Hooks:");
  console.log(`  SessionEnd:  ${status.hooks.sessionEnd ? "installed" : "not installed"}`);
  console.log(`  PreCompact:  ${status.hooks.preCompact ? "installed" : "not installed"}`);
  console.log(`  Hook script: ${status.hooks.hookScriptExists ? "present" : "missing"}`);
  console.log(`  Backup:      ${status.hooks.backupExists ? "available" : "none"}`);
  console.log("");

  console.log("Configuration:");
  console.log(`  autoSync:          ${status.config.autoSync}`);
  console.log(`  syncOnCompaction:  ${status.config.syncOnCompaction}`);
  console.log(`  recoveryOnStartup: ${status.config.recoveryOnStartup}`);
  console.log(`  timeout:           ${status.config.timeout}ms`);
  console.log(`  logLevel:          ${status.config.logLevel}`);
  console.log(`  showFailures:      ${status.config.showFailures}`);
  console.log("");

  console.log("Activity:");
  console.log(`  Last sync:         ${status.lastSync ?? "never"}`);
  console.log(`  Pending sessions:  ${status.pendingSessions}`);
  console.log(`  Recent log entries: ${status.recentLogs}`);

  // Recommendations
  if (!status.hooks.sessionEnd || !status.hooks.preCompact) {
    console.log("\nRecommendation: Run 'aidev memory install' to enable automatic sync.");
  }
  if (status.pendingSessions > 0) {
    console.log(`\nNote: ${status.pendingSessions} session(s) pending sync. Run 'aidev memory sync' to sync now.`);
  }
}
```

Update commands/index.ts to export new commands:
```typescript
export { createInstallCommand } from "./install.js";
export { createUninstallCommand } from "./uninstall.js";
export { createStatusCommand } from "./status.js";
```

Update presentation/cli/index.ts to add commands:
```typescript
import {
  createSyncCommand,
  createSearchCommand,
  createListCommand,
  createStatsCommand,
  createContextCommand,
  createRelatedCommand,
  createInstallCommand,
  createUninstallCommand,
  createStatusCommand,
} from "./commands/index.js";

// Add to program
program.addCommand(createInstallCommand());
program.addCommand(createUninstallCommand());
program.addCommand(createStatusCommand());
```

Tests for status should cover:
- Status shows hook installation state
- Status shows config values
- Status shows pending sessions count
- Status handles missing database gracefully
- Status --json outputs valid JSON
  </action>
  <verify>
Run `bun test status` - all tests pass
Run `bun test` - all tests pass
Commands available: `bun run src/presentation/cli/index.ts install --help`
  </verify>
  <done>
status, install, and uninstall commands integrated into CLI with proper output formatting
  </done>
</task>

</tasks>

<verification>
1. `bun test settings-manager` passes all tests
2. `bun test install` passes all tests
3. `bun test uninstall` passes all tests
4. `bun test status` passes all tests
5. `bun test` passes all existing tests (no regressions)
6. Commands appear in CLI help: `bun run src/presentation/cli/index.ts --help`
7. Install creates backup before modifying settings.json
8. Status shows accurate hook state and pending count
</verification>

<success_criteria>
1. settings-manager safely modifies Claude Code settings with backup
2. installHooks adds SessionEnd and PreCompact hooks
3. uninstallHooks removes only memory-nexus hooks
4. Install command copies hook script to ~/.memory-nexus/hooks/
5. Install command is idempotent without --force
6. Uninstall command cleanly removes all artifacts
7. Uninstall --restore option works when backup exists
8. Status command shows hooks, config, and activity
9. Status --json outputs machine-readable format
10. All commands integrated into CLI entry point
</success_criteria>

<output>
After completion, create `.planning/phases/10-hook-integration/10-03-SUMMARY.md`
</output>
