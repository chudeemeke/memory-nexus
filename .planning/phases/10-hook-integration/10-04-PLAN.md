---
phase: 10-hook-integration
plan: 04
type: execute
wave: 3
depends_on: ["10-03"]
files_modified:
  - src/application/services/recovery-service.ts
  - src/application/services/recovery-service.test.ts
  - src/application/services/index.ts
  - src/presentation/cli/commands/stats.ts
  - src/presentation/cli/formatters/stats-formatter.ts
  - docs/HOOKS.md
autonomous: true

must_haves:
  truths:
    - "Recovery service identifies sessions not yet synced"
    - "Recovery service can trigger sync for pending sessions"
    - "Stats command includes hook status summary"
    - "Documentation explains hook installation and configuration"
    - "Documentation includes troubleshooting guide"
  artifacts:
    - path: "src/application/services/recovery-service.ts"
      provides: "Service for detecting and syncing unsaved sessions"
      exports: ["RecoveryService"]
    - path: "docs/HOOKS.md"
      provides: "User documentation for hook system"
      min_lines: 100
  key_links:
    - from: "recovery-service.ts"
      to: "sync-service.ts"
      via: "sync call"
      pattern: "SyncService"
    - from: "stats.ts"
      to: "settings-manager.ts checkHooksInstalled"
      via: "function call"
      pattern: "checkHooksInstalled"
---

<objective>
Complete hook integration with recovery service, stats enhancement, and documentation.

Purpose: The recovery service enables crash recovery by detecting sessions that haven't been synced (useful if hooks failed or were disabled). Stats command enhancement gives users visibility into hook status without running a separate command. Documentation ensures users can install, configure, and troubleshoot the hook system.

Output: Working recovery service, enhanced stats output, and comprehensive HOOKS.md documentation.
</objective>

<execution_context>
@C:\Users\Destiny\.claude/get-stuff-done/workflows/execute-plan.md
@C:\Users\Destiny\.claude/get-stuff-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-hook-integration/10-CONTEXT.md
@.planning/phases/10-hook-integration/10-RESEARCH.md
@.planning/phases/10-hook-integration/10-01-PLAN.md
@.planning/phases/10-hook-integration/10-02-PLAN.md
@.planning/phases/10-hook-integration/10-03-PLAN.md

@src/application/services/sync-service.ts
@src/presentation/cli/commands/stats.ts
@src/presentation/cli/formatters/stats-formatter.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RecoveryService for detecting and syncing pending sessions</name>
  <files>
    src/application/services/recovery-service.ts
    src/application/services/recovery-service.test.ts
    src/application/services/index.ts
  </files>
  <action>
Create recovery-service.ts for crash recovery functionality:

```typescript
import type { ISessionSource } from "../../domain/ports/sources.js";
import type { IExtractionStateRepository } from "../../domain/ports/repositories.js";
import { logSync, loadConfig } from "../../infrastructure/hooks/index.js";
import type { SyncService, SyncResult } from "./sync-service.js";

export interface RecoveryResult {
  pendingSessions: string[];
  syncedSessions: number;
  errors: Array<{ sessionPath: string; error: string }>;
  skipped: boolean;  // True if recovery disabled in config
}

export interface RecoveryOptions {
  dryRun?: boolean;  // Just report pending, don't sync
  maxSessions?: number;  // Limit number of sessions to sync
}

export class RecoveryService {
  constructor(
    private readonly sessionSource: ISessionSource,
    private readonly extractionStateRepo: IExtractionStateRepository,
    private readonly syncService: SyncService
  ) {}

  /**
   * Check for sessions that haven't been synced and optionally sync them.
   *
   * Called on startup when recoveryOnStartup is enabled, or manually
   * via CLI. Useful for crash recovery when hooks failed.
   */
  async recover(options: RecoveryOptions = {}): Promise<RecoveryResult> {
    const config = loadConfig();

    // Check if recovery is enabled (unless explicit dryRun)
    if (!config.recoveryOnStartup && !options.dryRun) {
      return {
        pendingSessions: [],
        syncedSessions: 0,
        errors: [],
        skipped: true,
      };
    }

    // Discover all sessions
    const sessions = await this.sessionSource.discoverSessions();

    // Find pending sessions (not synced or incomplete)
    const pendingSessions: string[] = [];
    for (const session of sessions) {
      const state = await this.extractionStateRepo.findBySessionPath(session.path);
      if (!state || state.status !== "complete") {
        pendingSessions.push(session.path);
      }
    }

    // Log discovery
    logSync({
      level: "info",
      message: `Recovery scan found ${pendingSessions.length} pending sessions`,
    });

    // If dry run, just return pending list
    if (options.dryRun) {
      return {
        pendingSessions,
        syncedSessions: 0,
        errors: [],
        skipped: false,
      };
    }

    // Sync pending sessions (up to maxSessions limit)
    const toSync = options.maxSessions
      ? pendingSessions.slice(0, options.maxSessions)
      : pendingSessions;

    let syncedCount = 0;
    const errors: Array<{ sessionPath: string; error: string }> = [];

    for (const sessionPath of toSync) {
      try {
        // Extract session ID from path (last component without .jsonl)
        const sessionId = extractSessionId(sessionPath);

        await this.syncService.sync({ sessionFilter: sessionId });
        syncedCount++;

        logSync({
          level: "info",
          message: `Recovery synced session ${sessionId}`,
          sessionId,
        });
      } catch (err) {
        const error = err instanceof Error ? err.message : String(err);
        errors.push({ sessionPath, error });

        logSync({
          level: "error",
          message: `Recovery failed for ${sessionPath}: ${error}`,
          error,
        });
      }
    }

    return {
      pendingSessions,
      syncedSessions: syncedCount,
      errors,
      skipped: false,
    };
  }

  /**
   * Get count of pending sessions without syncing.
   * Fast operation for status display.
   */
  async getPendingCount(): Promise<number> {
    const sessions = await this.sessionSource.discoverSessions();
    let count = 0;

    for (const session of sessions) {
      const state = await this.extractionStateRepo.findBySessionPath(session.path);
      if (!state || state.status !== "complete") {
        count++;
      }
    }

    return count;
  }
}

function extractSessionId(sessionPath: string): string {
  const parts = sessionPath.split(/[/\\]/);
  const filename = parts[parts.length - 1];
  return filename.replace(/\.jsonl$/, "");
}
```

Update application/services/index.ts:
```typescript
export { RecoveryService, type RecoveryResult, type RecoveryOptions } from "./recovery-service.js";
```

Tests should cover:
- recover() finds pending sessions correctly
- recover() respects recoveryOnStartup config
- recover() dryRun returns pending without syncing
- recover() maxSessions limits sync count
- recover() handles sync errors gracefully
- getPendingCount() returns accurate count
- extractSessionId() handles Windows/Unix paths

Use mocks for sessionSource, extractionStateRepo, and syncService.
  </action>
  <verify>
Run `bun test recovery-service` - all tests pass
  </verify>
  <done>
RecoveryService detects pending sessions and triggers sync with configurable behavior
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance stats command with hook status summary</name>
  <files>
    src/presentation/cli/commands/stats.ts
    src/presentation/cli/commands/stats.test.ts
    src/presentation/cli/formatters/stats-formatter.ts
    src/presentation/cli/formatters/stats-formatter.test.ts
  </files>
  <action>
Update stats command to include hook status:

1. Import hook infrastructure:
```typescript
import {
  checkHooksInstalled,
  loadConfig,
  type HookStatus,
  type MemoryNexusConfig,
} from "../../../infrastructure/hooks/index.js";
```

2. Extend StatsInfo type in stats-formatter.ts or stats.ts:
```typescript
interface HooksSummary {
  installed: boolean;
  autoSync: boolean;
  pendingSessions: number;
}

interface ExtendedStatsInfo extends StatsInfo {
  hooks?: HooksSummary;
}
```

3. Update gatherStats() to include hook info:
```typescript
async function gatherStats(): Promise<ExtendedStatsInfo> {
  // Existing stats gathering...

  // Add hook status
  const hookStatus = checkHooksInstalled();
  const config = loadConfig();

  // Get pending count (reuse from status command or RecoveryService)
  let pendingSessions = 0;
  try {
    const sessionSource = new FileSystemSessionSource();
    const extractionStateRepo = new SqliteExtractionStateRepository(db);

    const allSessions = await sessionSource.discoverSessions();
    for (const session of allSessions) {
      const state = await extractionStateRepo.findBySessionPath(session.path);
      if (!state || state.status !== "complete") {
        pendingSessions++;
      }
    }
  } catch {
    // Ignore errors
  }

  return {
    ...existingStats,
    hooks: {
      installed: hookStatus.sessionEnd && hookStatus.preCompact,
      autoSync: config.autoSync,
      pendingSessions,
    },
  };
}
```

4. Update stats formatter to display hook info:
```typescript
function formatStatsOutput(stats: ExtendedStatsInfo): string {
  const lines: string[] = [];

  // Existing stats output...

  // Add hooks section
  if (stats.hooks) {
    lines.push("");
    lines.push("Hooks:");
    lines.push(`  Installed:        ${stats.hooks.installed ? "yes" : "no"}`);
    lines.push(`  Auto-sync:        ${stats.hooks.autoSync ? "enabled" : "disabled"}`);
    lines.push(`  Pending sessions: ${stats.hooks.pendingSessions}`);

    if (!stats.hooks.installed) {
      lines.push("");
      lines.push("  Run 'aidev memory install' to enable automatic sync");
    }
  }

  return lines.join("\n");
}
```

5. Update JSON output to include hooks:
```typescript
// In --json output
{
  ...existingFields,
  hooks: {
    installed: true,
    autoSync: true,
    pendingSessions: 5
  }
}
```

Tests should cover:
- Stats includes hook status in output
- Stats shows "not installed" when hooks missing
- Stats shows "disabled" when autoSync false
- Stats JSON includes hooks object
- Existing stats tests still pass
  </action>
  <verify>
Run `bun test stats` - all tests pass
Run `bun run src/presentation/cli/index.ts stats` - shows hook status
  </verify>
  <done>
Stats command displays hook installation state, auto-sync status, and pending session count
  </done>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive HOOKS.md documentation</name>
  <files>
    docs/HOOKS.md
  </files>
  <action>
Create docs/HOOKS.md with comprehensive documentation:

```markdown
# Hook Integration Guide

Memory-nexus can automatically sync Claude Code sessions using the hook system. When a session ends or context is compacted, hooks trigger a background sync that persists your conversation to the searchable database.

## Quick Start

```bash
# Install hooks (one-time setup)
aidev memory install

# Check status
aidev memory status

# Uninstall if needed
aidev memory uninstall
```

## How It Works

### Hook Events

Memory-nexus uses two Claude Code hook events:

1. **SessionEnd** - Triggers when:
   - User exits Claude Code
   - Session is cleared
   - User logs out

2. **PreCompact** - Triggers when:
   - Context window reaches capacity
   - Automatic compaction occurs

Both events provide the session ID, enabling targeted sync of just the affected session.

### Background Execution

Hooks spawn a detached background process that:
- Runs independently of Claude Code
- Continues even if Claude Code exits
- Logs activity to `~/.memory-nexus/logs/sync.log`
- Never blocks the terminal or Claude Code

### What Gets Synced

Each sync extracts:
- User messages
- Assistant responses (excluding thinking blocks)
- Tool uses (name, inputs, outputs)
- Session metadata (project, timestamps)

## Configuration

Configuration is stored in `~/.memory-nexus/config.json`:

```json
{
  "autoSync": true,
  "recoveryOnStartup": true,
  "syncOnCompaction": true,
  "timeout": 5000,
  "logLevel": "info",
  "logRetentionDays": 7,
  "showFailures": false
}
```

### Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `autoSync` | boolean | true | Enable automatic hook-based sync |
| `recoveryOnStartup` | boolean | true | Scan for unsaved sessions on first command |
| `syncOnCompaction` | boolean | true | Sync when context is compacted |
| `timeout` | number | 5000 | Sync timeout in milliseconds |
| `logLevel` | string | "info" | Logging level (debug/info/warn/error) |
| `logRetentionDays` | number | 7 | Days to keep log files |
| `showFailures` | boolean | false | Show failure notifications to user |

### Editing Configuration

Edit the config file directly or use environment-specific overrides:

```bash
# View current config
cat ~/.memory-nexus/config.json

# Edit with your preferred editor
code ~/.memory-nexus/config.json
```

Changes apply on the next hook trigger (no restart needed).

## Installation Details

### What `install` Does

1. Backs up existing `~/.claude/settings.json`
2. Copies hook script to `~/.memory-nexus/hooks/sync-hook.js`
3. Adds SessionEnd and PreCompact hooks to Claude Code settings
4. Validates installation

### Manual Installation

If automatic installation fails, you can manually add hooks to `~/.claude/settings.json`:

```json
{
  "hooks": {
    "SessionEnd": [
      {
        "hooks": [{
          "type": "command",
          "command": "bun run \"~/.memory-nexus/hooks/sync-hook.js\"",
          "timeout": 5
        }]
      }
    ],
    "PreCompact": [
      {
        "matcher": "auto",
        "hooks": [{
          "type": "command",
          "command": "bun run \"~/.memory-nexus/hooks/sync-hook.js\"",
          "timeout": 5
        }]
      }
    ]
  }
}
```

### Uninstallation

```bash
# Remove hooks (preserves database)
aidev memory uninstall

# Restore original settings from backup
aidev memory uninstall --restore
```

## Troubleshooting

### Check Status

```bash
aidev memory status
```

Shows:
- Hook installation state
- Configuration values
- Last sync time
- Pending sessions count

### View Logs

```bash
# Recent log entries
tail -f ~/.memory-nexus/logs/sync.log

# Search for errors
grep '"level":"error"' ~/.memory-nexus/logs/sync.log
```

Log format (JSON lines):
```json
{"timestamp":"2024-01-15T10:30:00.000Z","level":"info","message":"Triggered sync for session abc123","sessionId":"abc123","hookEvent":"SessionEnd"}
```

### Common Issues

#### Hooks Not Triggering

1. Check hooks are installed: `aidev memory status`
2. Verify `autoSync: true` in config
3. Check Claude Code recognizes hooks: restart Claude Code
4. Check logs for errors

#### Sync Failing

1. Check log file for errors
2. Verify database is accessible: `aidev memory stats`
3. Try manual sync: `aidev memory sync`
4. Check disk space

#### Settings.json Corrupted

1. Restore from backup:
   ```bash
   aidev memory uninstall --restore
   ```
2. Or manually restore:
   ```bash
   cp ~/.memory-nexus/backups/settings.json.backup ~/.claude/settings.json
   ```

### Recovery

If hooks were disabled or failed, run manual recovery:

```bash
# See pending sessions
aidev memory status

# Sync all pending
aidev memory sync
```

## Disabling Auto-Sync

To disable automatic sync while keeping hooks installed:

```json
// ~/.memory-nexus/config.json
{
  "autoSync": false
}
```

Or uninstall hooks entirely:

```bash
aidev memory uninstall
```

Manual sync remains available:

```bash
aidev memory sync
```

## File Locations

| Path | Purpose |
|------|---------|
| `~/.memory-nexus/config.json` | User configuration |
| `~/.memory-nexus/hooks/sync-hook.js` | Hook script |
| `~/.memory-nexus/logs/sync.log` | Sync activity log |
| `~/.memory-nexus/backups/settings.json.backup` | Settings backup |
| `~/.claude/settings.json` | Claude Code settings (modified by install) |
| `~/.memory-nexus/memory-nexus.sqlite` | Session database |

## Security Considerations

- Hook script runs with user permissions
- No data leaves your machine
- Database is local SQLite
- Logs may contain session IDs (not content)
```

Ensure the documentation:
- Is clear and actionable
- Includes code examples
- Has troubleshooting section
- Covers all configuration options
- Explains file locations
  </action>
  <verify>
File exists and contains all sections
Documentation is accurate and matches implementation
  </verify>
  <done>
HOOKS.md provides comprehensive guide for installation, configuration, and troubleshooting
  </done>
</task>

</tasks>

<verification>
1. `bun test recovery-service` passes all tests
2. `bun test stats` passes all tests (including new hook status tests)
3. `bun test` passes all existing tests (no regressions)
4. Stats command shows hook status in output
5. HOOKS.md covers installation, configuration, troubleshooting
6. Documentation file locations match actual implementation
</verification>

<success_criteria>
1. RecoveryService detects sessions not yet synced
2. RecoveryService respects recoveryOnStartup config
3. RecoveryService handles errors gracefully with logging
4. Stats command shows hook installation state
5. Stats command shows autoSync status and pending count
6. Stats --json includes hooks object
7. HOOKS.md explains installation process
8. HOOKS.md documents all configuration options
9. HOOKS.md includes troubleshooting guide
10. All file paths in docs match implementation
</success_criteria>

<output>
After completion, create `.planning/phases/10-hook-integration/10-04-SUMMARY.md`
</output>
