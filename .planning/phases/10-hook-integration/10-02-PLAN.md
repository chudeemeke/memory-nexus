---
phase: 10-hook-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/infrastructure/hooks/hook-runner.ts
  - src/infrastructure/hooks/hook-runner.test.ts
  - src/infrastructure/hooks/sync-hook-script.ts
  - src/infrastructure/hooks/index.ts
autonomous: true

must_haves:
  truths:
    - "Hook runner spawns detached background process"
    - "Spawned process survives parent termination"
    - "Hook runner redirects output to sync.log"
    - "Hook script reads JSON input from stdin"
    - "Hook script extracts session_id from input"
    - "Hook script respects autoSync config setting"
    - "Hook script fails gracefully when session_id missing"
  artifacts:
    - path: "src/infrastructure/hooks/hook-runner.ts"
      provides: "Background process spawner for sync"
      exports: ["spawnBackgroundSync"]
    - path: "src/infrastructure/hooks/sync-hook-script.ts"
      provides: "Entry point script for Claude Code hooks"
      min_lines: 50
  key_links:
    - from: "hook-runner.ts"
      to: "node:child_process spawn"
      via: "detached process"
      pattern: "spawn.*detached.*true"
    - from: "sync-hook-script.ts"
      to: "hook-runner.ts"
      via: "spawnBackgroundSync call"
      pattern: "spawnBackgroundSync"
    - from: "sync-hook-script.ts"
      to: "config-manager.ts"
      via: "loadConfig call"
      pattern: "loadConfig"
---

<objective>
Create the hook runner for background sync spawning and the hook script entry point.

Purpose: Claude Code hooks execute commands when sessions end or context compacts. The hook script reads session info from stdin, checks configuration, then spawns a detached background sync process. This design ensures hooks exit immediately (within 5s timeout) while sync continues independently.

Output: Working hook-runner.ts for spawning detached processes and sync-hook-script.ts as the hook command target.
</objective>

<execution_context>
@C:\Users\Destiny\.claude/get-stuff-done/workflows/execute-plan.md
@C:\Users\Destiny\.claude/get-stuff-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-hook-integration/10-CONTEXT.md
@.planning/phases/10-hook-integration/10-RESEARCH.md

@src/presentation/cli/commands/sync.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create hook-runner with detached process spawning</name>
  <files>
    src/infrastructure/hooks/hook-runner.ts
    src/infrastructure/hooks/hook-runner.test.ts
  </files>
  <action>
Create hook-runner.ts following the research patterns:

1. Import required modules:
```typescript
import { spawn } from "node:child_process";
import { openSync, mkdirSync, existsSync } from "node:fs";
import { homedir } from "node:os";
import { join } from "node:path";
```

2. Implement getCliCommand():
- Returns the command to run sync CLI
- For bun projects: `bun run` with path to CLI entry
- For aidev integration: `aidev memory sync`
- Make configurable via function parameter with default

3. Implement ensureLogDirectory():
- Create ~/.memory-nexus/logs/ if missing
- Return log file path

4. Implement spawnBackgroundSync(sessionId: string, options?: SpawnOptions):
```typescript
export interface SpawnOptions {
  command?: string;  // Override CLI command (for testing)
  quiet?: boolean;   // Default true
}

export function spawnBackgroundSync(
  sessionId: string,
  options: SpawnOptions = {}
): void {
  const { command = "aidev", quiet = true } = options;

  // Ensure log directory exists
  const logDir = join(homedir(), ".memory-nexus", "logs");
  mkdirSync(logDir, { recursive: true });

  const logPath = join(logDir, "sync.log");
  const out = openSync(logPath, "a");
  const err = openSync(logPath, "a");

  const args = ["memory", "sync", "--session", sessionId];
  if (quiet) args.push("--quiet");

  const subprocess = spawn(command, args, {
    detached: true,
    stdio: ["ignore", out, err],
    env: { ...process.env, MEMORY_NEXUS_HOOK: "1" },
  });

  subprocess.unref();  // Allow parent to exit
}
```

Key implementation details:
- detached: true - Process runs in own process group
- stdio: Redirect to log file (not 'ignore' - we want logs)
- unref() - Parent can exit without waiting
- MEMORY_NEXUS_HOOK env var - Sync can detect hook invocation

Tests should cover:
- spawnBackgroundSync creates log directory if missing
- spawnBackgroundSync spawns process with correct arguments
- spawnBackgroundSync includes --session flag
- spawnBackgroundSync includes --quiet flag by default
- Process can be verified as spawned (check PID exists briefly)

Note: Testing spawned processes is tricky. Use spy/mock on spawn to verify arguments, or create integration test that verifies file was written.

Consider: Create a testable wrapper that accepts spawn function as dependency injection for easier testing.
  </action>
  <verify>
Run `bun test hook-runner` - all tests pass
  </verify>
  <done>
spawnBackgroundSync spawns detached process with correct CLI arguments and stdio redirect
  </done>
</task>

<task type="auto">
  <name>Task 2: Create sync-hook-script as Claude Code hook entry point</name>
  <files>
    src/infrastructure/hooks/sync-hook-script.ts
  </files>
  <action>
Create sync-hook-script.ts as the entry point for Claude Code hooks:

1. Define HookInput interface (from research):
```typescript
interface HookInput {
  session_id?: string;
  transcript_path?: string;
  hook_event_name: string;
  reason?: string;      // SessionEnd: "clear", "logout", "prompt_input_exit", "other"
  trigger?: string;     // PreCompact: "manual" or "auto"
  cwd?: string;
  permission_mode?: string;
}
```

2. Import dependencies:
```typescript
import { loadConfig } from "./config-manager.js";
import { logSync } from "./log-writer.js";
import { spawnBackgroundSync } from "./hook-runner.js";
```

3. Implement readStdinJson():
- Read from process.stdin
- Collect chunks until EOF
- Parse JSON and return
- Handle parse errors gracefully

```typescript
async function readStdinJson(): Promise<HookInput> {
  return new Promise((resolve, reject) => {
    let input = "";
    process.stdin.setEncoding("utf-8");
    process.stdin.on("data", (chunk) => { input += chunk; });
    process.stdin.on("end", () => {
      try {
        resolve(JSON.parse(input));
      } catch (err) {
        reject(new Error("Failed to parse hook input JSON"));
      }
    });
    process.stdin.on("error", reject);
  });
}
```

4. Implement main():
```typescript
async function main(): Promise<void> {
  const config = loadConfig();

  // Check if auto-sync is enabled
  if (!config.autoSync) {
    process.exit(0);  // Disabled by config
  }

  // Read hook input from stdin
  let hookInput: HookInput;
  try {
    hookInput = await readStdinJson();
  } catch (err) {
    logSync({ level: "error", message: `Failed to read hook input: ${err.message}` });
    process.exit(0);  // Never block user
  }

  // Check if this hook type is enabled
  if (hookInput.hook_event_name === "PreCompact" && !config.syncOnCompaction) {
    process.exit(0);
  }

  // Extract session ID
  const sessionId = hookInput.session_id;
  if (!sessionId) {
    logSync({
      level: "warn",
      message: `No session_id in ${hookInput.hook_event_name} hook input`,
      hookEvent: hookInput.hook_event_name,
    });
    process.exit(0);  // Fail gracefully
  }

  // Spawn background sync
  spawnBackgroundSync(sessionId);

  logSync({
    level: "info",
    message: `Triggered sync for session ${sessionId}`,
    sessionId,
    hookEvent: hookInput.hook_event_name,
  });

  process.exit(0);
}

// Run
main().catch((err) => {
  logSync({ level: "error", message: `Hook error: ${err.message}`, error: err.stack });
  process.exit(0);  // Never block user
});
```

5. Add shebang for direct execution:
```typescript
#!/usr/bin/env bun
```

6. Export types and readStdinJson for testing:
```typescript
export { HookInput, readStdinJson };
```

Key implementation details:
- Always exit 0 to not block Claude Code
- Log all operations for debugging
- Check config before processing
- Graceful handling of missing session_id
- Hook event name tracked in logs
  </action>
  <verify>
File compiles without errors: `bun build src/infrastructure/hooks/sync-hook-script.ts --outdir=dist`
  </verify>
  <done>
sync-hook-script.ts reads stdin JSON, checks config, and spawns background sync with proper logging
  </done>
</task>

<task type="auto">
  <name>Task 3: Add hook-runner exports to barrel and create build script</name>
  <files>
    src/infrastructure/hooks/index.ts
    package.json
  </files>
  <action>
Update hooks/index.ts to include hook-runner exports:

```typescript
// Add to existing exports
export {
  spawnBackgroundSync,
  type SpawnOptions,
} from "./hook-runner.js";

export {
  type HookInput,
  readStdinJson,
} from "./sync-hook-script.js";
```

Add build script to package.json for hook script:

```json
{
  "scripts": {
    "build:hook": "bun build src/infrastructure/hooks/sync-hook-script.ts --outfile=dist/sync-hook.js --target=bun"
  }
}
```

The built hook script will be installed to ~/.memory-nexus/hooks/sync-hook.js by the install command (Plan 03).

Note on testing sync-hook-script:
- Unit testing stdin reading is complex
- Create integration test that pipes JSON to script
- Test via spawn with piped stdin:

```typescript
// In integration test
const child = spawn("bun", ["run", "src/infrastructure/hooks/sync-hook-script.ts"], {
  stdio: ["pipe", "pipe", "pipe"],
});
child.stdin.write(JSON.stringify({ session_id: "test-123", hook_event_name: "SessionEnd" }));
child.stdin.end();
```

Consider adding a --test flag to sync-hook-script that exits after logging without spawning, for easier testing.
  </action>
  <verify>
Run `bun run build:hook` - creates dist/sync-hook.js
Run `bun test` - all tests pass
  </verify>
  <done>
hook-runner exports available, build script creates distributable hook script
  </done>
</task>

</tasks>

<verification>
1. `bun test hook-runner` passes all tests
2. `bun run build:hook` creates dist/sync-hook.js
3. `bun test` passes all existing tests (no regressions)
4. Hook script reads JSON from stdin correctly
5. Hook script respects autoSync and syncOnCompaction config
6. Hook script logs operations with session ID and hook event
7. spawn() called with detached: true (verified via test spy)
</verification>

<success_criteria>
1. spawnBackgroundSync creates detached child process
2. Detached process runs `aidev memory sync --session <id> --quiet`
3. Process output redirected to ~/.memory-nexus/logs/sync.log
4. sync-hook-script reads HookInput from stdin
5. sync-hook-script checks autoSync config before proceeding
6. sync-hook-script handles PreCompact with syncOnCompaction check
7. Missing session_id logged as warning, exits gracefully
8. Hook always exits 0 (never blocks Claude Code)
9. Build script creates distributable hook file
</success_criteria>

<output>
After completion, create `.planning/phases/10-hook-integration/10-02-SUMMARY.md`
</output>
