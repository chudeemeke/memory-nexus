# Plan 03-02: Streaming JSONL Parser Implementation

## Objective

Implement `JsonlEventParser` that parses JSONL session files using streaming to handle large files (10,000+ lines) without memory exhaustion.

## Requirements Addressed

| ID | Requirement |
|----|-------------|
| PARSE-01 | Streaming JSONL parser using readline.createInterface (never load entire file) |
| PARSE-08 | Graceful handling of malformed JSON lines (skip and log with line number) |
| STOR-05 | JsonlEventParser implementing IEventParser |

## Tasks

### Task 1: Create Parser Adapter Shell

**File:** `src/infrastructure/parsers/jsonl-parser.ts`

Create the file structure:

```typescript
import { createReadStream } from "fs";
import { createInterface } from "readline";
import type { IEventParser, ParsedEvent } from "../../domain/ports/index.js";

export class JsonlEventParser implements IEventParser {
  async *parse(filePath: string): AsyncGenerator<ParsedEvent> {
    throw new Error("Not implemented");
  }
}
```

**Tests:**
- Parser class implements IEventParser interface

### Task 2: Implement Streaming Line Reader

Use Node's readline with createReadStream for line-by-line processing.

**Logic:**
```typescript
const fileStream = createReadStream(filePath, { encoding: "utf8" });
const rl = createInterface({
  input: fileStream,
  crlfDelay: Infinity,
});

let lineNum = 0;
for await (const line of rl) {
  lineNum++;
  // Parse line
}
```

**Tests:**
- Yields events for valid JSONL
- Handles empty files (yields nothing)
- Handles large files without memory spike
- Processes each line independently

### Task 3: Implement JSON Parse with Error Handling

Parse each line as JSON, yielding "skipped" for malformed lines.

**Logic:**
```typescript
try {
  const event = JSON.parse(line);
  yield classifyEvent(event);
} catch (err) {
  yield {
    type: "skipped",
    reason: `Malformed JSON at line ${lineNum}: ${err.message}`
  };
}
```

**Tests:**
- Parses valid JSON lines
- Yields skipped event for invalid JSON
- Includes line number in error message
- Continues parsing after malformed line
- Handles empty lines (skip or parse error)

### Task 4: Implement Event Type Detection

Detect event type from the parsed JSON object.

**Logic:**
```typescript
function detectEventType(event: unknown): string {
  if (typeof event !== "object" || event === null) {
    return "unknown";
  }
  const obj = event as Record<string, unknown>;
  return typeof obj.type === "string" ? obj.type : "unknown";
}
```

**Tests:**
- Detects user, assistant, summary, system types
- Returns "unknown" for missing type field
- Returns "unknown" for non-object values

### Task 5: Create Index and Integration

**File:** `src/infrastructure/parsers/index.ts`

Export the parser and update infrastructure index.

**Tests:**
- Export is accessible from infrastructure index

## Success Criteria

1. Parser uses streaming - never loads entire file into memory
2. Memory usage stays flat when parsing 10,000+ line file
3. Malformed lines are skipped with informative reason
4. All tests pass

## Dependencies

- Phase 2 port interfaces (IEventParser, ParsedEvent)

## Test Count Estimate

~15 unit tests

## Files to Create/Modify

| File | Action |
|------|--------|
| src/infrastructure/parsers/jsonl-parser.ts | Create |
| src/infrastructure/parsers/jsonl-parser.test.ts | Create |
| src/infrastructure/parsers/index.ts | Create |
| src/infrastructure/index.ts | Modify (add export) |

---

*Created: 2026-01-28*
