---
phase: 07-filtering-and-output-formatting
plan: 03
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/presentation/cli/formatters/output-formatter.ts
  - src/presentation/cli/formatters/output-formatter.test.ts
  - src/presentation/cli/formatters/color.ts
  - src/presentation/cli/formatters/color.test.ts
  - src/presentation/cli/formatters/index.ts
autonomous: true

must_haves:
  truths:
    - "JSON mode outputs valid JSON array with all result fields"
    - "Quiet mode suppresses headers and decorations but still outputs results"
    - "Verbose mode shows full content and execution details"
    - "Color output auto-detects TTY (colors in terminal, plain when piped)"
    - "Output respects ~50K character budget for Claude context"
  artifacts:
    - path: "src/presentation/cli/formatters/output-formatter.ts"
      provides: "Output formatting strategy with mode selection"
      exports: ["createOutputFormatter", "OutputMode", "FormatOptions"]
    - path: "src/presentation/cli/formatters/color.ts"
      provides: "TTY-aware color utilities"
      exports: ["shouldUseColor", "bold", "dim", "green", "red"]
  key_links:
    - from: "src/presentation/cli/formatters/output-formatter.ts"
      to: "src/presentation/cli/formatters/timestamp-formatter.ts"
      via: "formatTimestamp for result display"
      pattern: "formatTimestamp"
    - from: "src/presentation/cli/formatters/color.ts"
      to: "process.stdout.isTTY"
      via: "TTY detection for color output"
      pattern: "isTTY"
---

<objective>
Create output formatting infrastructure with mode selection and TTY-aware color.

Purpose: Standardize output across all commands with consistent formatting. Support multiple modes (default, JSON, quiet, verbose) and respect context window limits for Claude consumption.

Output: OutputFormatter strategy pattern with color utilities and context budget enforcement.
</objective>

<execution_context>
@~/.claude/get-stuff-done/workflows/execute-plan.md
@~/.claude/get-stuff-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-filtering-and-output-formatting/07-CONTEXT.md
@.planning/phases/07-filtering-and-output-formatting/07-RESEARCH.md
</context>

<feature>
  <name>TTY-Aware Color Utilities</name>
  <files>
    src/presentation/cli/formatters/color.ts
    src/presentation/cli/formatters/color.test.ts
  </files>
  <behavior>
TDD approach for color utilities.

Input -> Expected Output:
- shouldUseColor() with TTY -> true
- shouldUseColor() with piped stdout -> false
- shouldUseColor() with NO_COLOR env -> false
- shouldUseColor() with FORCE_COLOR env -> true (overrides non-TTY)
- bold("text") with color -> "\x1b[1mtext\x1b[0m"
- bold("text") without color -> "text"
- dim("text") with color -> "\x1b[2mtext\x1b[0m"
- green("text") with color -> "\x1b[32mtext\x1b[0m"
- red("text") with color -> "\x1b[31mtext\x1b[0m"
  </behavior>
  <implementation>
1. Create shouldUseColor(options?: { isTTY?: boolean; noColor?: boolean; forceColor?: boolean }): boolean
   - Default isTTY to process.stdout.isTTY
   - Default noColor to !!process.env.NO_COLOR
   - Default forceColor to !!process.env.FORCE_COLOR
   - Priority: noColor > forceColor > isTTY

2. Create colorize(text: string, code: string, useColor: boolean): string
   - If useColor: wrap with ANSI codes
   - If not: return plain text

3. Create convenience functions that call colorize:
   - bold(text, useColor?): "\x1b[1m"
   - dim(text, useColor?): "\x1b[2m"
   - green(text, useColor?): "\x1b[32m"
   - red(text, useColor?): "\x1b[31m"
   - yellow(text, useColor?): "\x1b[33m"

4. Tests should mock isTTY and env vars for determinism.
  </implementation>
</feature>

<feature>
  <name>Output Formatter Strategy</name>
  <files>
    src/presentation/cli/formatters/output-formatter.ts
    src/presentation/cli/formatters/output-formatter.test.ts
  </files>
  <behavior>
TDD approach for output formatting.

OutputMode enum: "default" | "json" | "quiet" | "verbose"

FormatOptions interface:
- mode: OutputMode
- useColor?: boolean
- contextBudget?: number (default 50000)
- query?: string (for "no results" message)
- executionDetails?: { ... } (for verbose mode)

formatSearchResults(results, options) behavior:

DEFAULT mode:
- Header: "Found N result(s):"
- Each result: score, session ID (8 chars), relative+absolute timestamp
- Snippet with bold highlighting
- Summary line: "Showing N of M results"
- Respects context budget

JSON mode:
- Full JSON array with all fields
- sessionId, messageId, content (full), snippet, score, timestamp, project, role
- No color, no decoration
- Respects context budget

QUIET mode:
- No header, no summary
- Just result lines (session ID and snippet)
- For piping

VERBOSE mode:
- Header with execution details (filters applied, time taken)
- Full content instead of snippet
- FTS5 query shown
- Session ID (full, not truncated)

Context budget enforcement:
- CONTEXT_BUDGET = 50000 chars
- Track output length
- Truncate results when budget exceeded
- Add note: "Output truncated (50K char limit)"
  </behavior>
  <implementation>
1. Define OutputMode type and FormatOptions interface

2. Create createOutputFormatter(mode: OutputMode, useColor: boolean):
   - Returns object with formatResults(), formatError(), formatSummary() methods
   - Factory pattern selects implementation based on mode

3. Implement formatSearchResults(results: SearchResult[], options: FormatOptions):
   - Switch on mode to select formatting logic
   - Build output string incrementally
   - Track character count against budget
   - Truncate with message if exceeded

4. Implement formatError(error: Error, mode: OutputMode):
   - All modes: "Error: <message>" to stderr
   - Verbose mode: include stack trace

5. Implement formatSummary(stats: { found: number, shown: number }, mode: OutputMode):
   - Default: "Found N results (showing M)"
   - JSON: included in output object
   - Quiet: skip
   - Verbose: detailed breakdown

Tests:
- Default mode formats results with colors (when useColor true)
- JSON mode outputs valid JSON
- Quiet mode has no headers/decorations
- Verbose mode shows full content
- Context budget truncates output correctly
- formatError outputs to stderr format
  </implementation>
</feature>

<verification>
Plan 07-03 verification:
1. shouldUseColor() returns correct value based on TTY/env
2. Color functions wrap text with correct ANSI codes
3. createOutputFormatter("json") outputs valid JSON
4. createOutputFormatter("quiet") has minimal decoration
5. Context budget of 50K chars enforced
6. All tests pass
</verification>

<success_criteria>
- color.ts provides shouldUseColor() with NO_COLOR/FORCE_COLOR support
- Color functions (bold, dim, green, red) work correctly
- output-formatter.ts provides strategy pattern for modes
- JSON mode outputs complete, valid JSON
- Quiet mode suitable for piping
- Verbose mode shows execution details
- Context budget (~50K chars) is enforced
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-filtering-and-output-formatting/07-03-SUMMARY.md`
</output>
